//@version=5
indicator("Kir Ondulatoire", shorttitle="KOndulat", overlay=true, max_labels_count=150, max_lines_count=100)

    // version 0.9.7

    // Copyright (C) 2024  Kir (https://github.com/Kirken2004/tv-kir-ondulat)

    // This program is free software; you can redistribute it and/or modify
    // it under the terms of the GNU General Public License as published by
    // the Free Software Foundation; either version 2 of the License, or
    // (at your option) any later version.

    // This program is distributed in the hope that it will be useful,
    // but WITHOUT ANY WARRANTY; without even the implied warranty of
    // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    // GNU Lesser General Public License for more details.

    // You should have received a copy of the GNU Lesser General Public License along
    // with this program; if not, write to the Free Software Foundation, Inc.,
    // 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

int       TIME_DEFAULT  = 0
float     PRICE_DEFAULT = 0.0

x1Input = input.time(TIME_DEFAULT,   "Point A", inline = "1", confirm = true)
y1Input = input.price(PRICE_DEFAULT, "",        inline = "1", tooltip = "Pick point A", confirm = true)
x2Input = input.time(TIME_DEFAULT,   "Point B", inline = "2", confirm = true)
y2Input = input.price(PRICE_DEFAULT, "",        inline = "2", tooltip = "Pick point B", confirm = true)
x3Input = input.time(TIME_DEFAULT,   "Point C", inline = "3", confirm = true)
y3Input = input.price(PRICE_DEFAULT, "",        inline = "3", tooltip = "Pick point C", confirm = true)
x4Input = input.time(TIME_DEFAULT,   "Point D", inline = "4", confirm = true)
y4Input = input.price(PRICE_DEFAULT, "",        inline = "4", tooltip = "Pick point D (place before C to ignore)", confirm = true)

wavt = input.bool(defval=true, title="Waves", inline="option0", group="Wave options")
wavc = input.color(defval=color.rgb(255, 255, 255, 66), title=" ", inline="option0", group="Wave options")
wavw = input.int(defval=3, title="Width ", options=[1,2,3,4,5], inline="option0", group="Wave options")
wavs = input.string(defval="dotted", title=" ", inline="option0", group="Wave options", options=["solid","dashed","dotted"])
pret = input.float(defval=50.0, title="% Retracement for a P-Wave", inline="option1", group="Wave options", tooltip="By default, a P wave is forming if the move BC retraced more than 50% of AB. N waves are more certain between 33% and 50%. Alter this if you think the situation is blurry.")
mult = input.bool(defval=false, title="Multiples of E/N waves", inline="option2", group="Wave options", tooltip="Won't work in case of an S-Wave.")
tim3 = input.bool(defval=false, title="Extend to deadline", inline="option2b", group="Wave options", tooltip="Extend the strength lines to the end of the target period (aka TIME #3).")
bcd4 = input.bool(defval=false, title="Project from BCD", inline="option3", group="Wave options", tooltip="BCD\nDraw new strength lines from D if placed after time C. Should be used when you are almost certain D is realised.")
ebox = input.bool(defval=true, title="Expected correction (E-Box)", inline="option3b", group="Wave options")
ecol = input.color(defval=color.aqua, title=" ", inline="option3b", group="Wave options", tooltip="E-Box\nNeed the point D to be placed after time C [STILL BUGGED AT THE MOMENT]. The drawn box indicates where and when a correction is expected. Can even be used if you are not sure about D.")
tend = input.bool(defval=false, title="Straight Linear Projection", inline="option4", group="Wave options", tooltip="SLP: As long as the TARGET TIME is not reached, a purple arrow will point to the target. A purple label will give the estimated target price. It's a silly feature.")
labp = input.bool(defval=false, title="Price in labels", inline="option5", group="Wave options")
tren = input.bool(defval=false, title="Wave Trend Lines", inline="option6", group="Wave options", tooltip = "Only visibles if D label is also visible. Help to visually confirm if ABCD is an N/Y/P wave.")
tcol = input.color(defval=color.green, title=" ", inline="option6", group="Wave options")
twid = input.int(defval=2, title="Width", inline="option6", group="Wave options")

ichi = input.bool(defval=false, title="Ichimoku Kinko Hyo", inline="option1", group="Ichimoku options")
crss = input.bool(defval=false, title="Tenkan Crossover/under markers.", inline="option2", group="Ichimoku options")
maxl = input.int(10, minval=1, title=" up to", inline="option2", group="Ichimoku options", tooltip = "An indicator is limited in the allowed amount of labels to draw. Keep this value low enough to prevent having lost labels.")

ksof = input.int(defval=0, title="Bar Offset", inline="option1", group="Kihon Suchi options")
ksmx = input.int(defval=42, title="Max period", inline="option1", group="Kihon Suchi options", tooltip = "Won't draw Ichimoku times after this elapsed period")
kisu = input.bool(defval=false, title="from last Crossover", inline="option2", group="Kihon Suchi options")
ksob = input.bool(defval=false, title="from B", inline="option2", group="Kihon Suchi options")
ksoc = input.bool(defval=false, title="from C", inline="option2", group="Kihon Suchi options", tooltip = "Cannot be 'from B' and 'from C' at the same time. Wont work either with 'from last Crossover' checked.")
tasu = input.bool(defval=true, title="Taito Suchi or any correlation", inline="option3", group="Kihon Suchi options", tooltip = "Search for an AC or BD correlation with Kihon Suchi numbers. +1/-1 also works. 26 is natural.")

ac26 = input.bool(defval=false, title="26 periods after A/C", inline="option1", group="Miscellaneous options", tooltip = "The Kumo cloud between those two deadlines gives an active area to keep an eye on. Up to you to draw a bounding box there.")
dema = input.bool(defval=false, title="EMA", inline="option2", group="Miscellaneous options")
fibo = input.bool(defval=false, title="Fibonacci Axis", inline="option3", group="Miscellaneous options")
cton = input.bool(defval=false, title="C to N/S", inline="option3", group="Miscellaneous options", tooltip="C to N/S: Gives you the expected pluvalue from C to N, then the realised ratio.\nN/AB gives you the current position on the fibo axis. To N/S when in continuation, to AB when retracing C.")

int timeZone = 2
int labelCount = 0
int nb_seconds = timeframe.in_seconds(timeframe.period)
int candleTime = nb_seconds * 1000

var tabKisu = table.new(position.bottom_center, 1, 1)
var tabCorr = table.new(position.bottom_right, 1, 1)
var tabTasu = table.new(position.top_right, 1, 1)

string n2pad = "{0, number, ##}"
string n3pad = "{0, number, ###}"
string n2dig = "{0, number, #.##}"
string n4dig = "{0, number, #.####}"
string stamp = 'dd-MMM-yyyy\nHH:mm:ss'

color priceLabelBgColor = color.rgb(120, 123, 134, 90)
color transparent = color.rgb(0, 0, 0, 100)
color boxColorBCD = color.rgb(210, 19, 98)
color veilColor = color.rgb(255,255,255,98)
color arrowColorNS = color.orange
color arrowColorEY = color.blue
color arrowColorVSm = color.rgb(255, 82, 102)
color arrowColorNtP = color.green
color retracementBgColor = color.rgb(70, 3, 81, 45)
color goldColor = color.rgb(255, 221, 117)
color transpWhiteColor = color.rgb(255, 255, 255, 34)
color transpTimeColor = color.rgb(0, 137, 123, 48)
color timeColor = color.rgb(0, 137, 123, 45)
color labelFiboTextColor = color.teal
color labelFiboTextColorNeg = color.rgb(0, 104, 93)
color labelFiboTextColorNegCrash = color.red
color labelFiboTextColorGoal = color.rgb(165, 209, 204)
color labelFiboTextColorGold = color.rgb(255, 224, 71)
color fiboScaleColor = color.rgb(31, 205, 187)
color fiboAxisColor = color.rgb(92, 234, 220)
color fiboZeroColor = color.rgb(31, 205, 187, 42)

type Wave
    int   time1
    int   time2
    int   time3
    int   time4
    int   timeD
    float price1
    float price2
    float price3
    float price4
    float price4Ex
    float priceD
    float priceDelta1
    float priceDelta2
    int   timeDelta1
    int   timeDelta2
    int   timeDelta3
    int   boxTime0
    int   boxTime1
    int   boxTimeE0
    int   boxTimeE1
    float boxTopPrice
    float boxTopPrice2
    float boxTopPrice3
    float boxTopPrice4
    float boxTopPrice5
    float boxEPrice
    float boxEPriceEx
    float boxVPrice
    float boxVPriceEx
    float boxNtPrice
    float boxNtPriceEx
    float boxPPrice
    float boxPPriceEx
    float boxYPrice
    float boxYPriceEx
    float boxSPrice
    float boxSPriceEx
    float boxSmPrice
    float boxSmPriceEx
    float boxPriceETop
    float boxPriceEBot
    float boxPriceEAnchor
    float boxPriceELabels
    float currentPrice
    float midADPrice
    int   currentTime
    bool  baNegative
    bool  nWave
    bool  pWave
    bool  sWave
    float retracement

lineStr2style(str) => 
    (str == "dotted") ? line.style_dotted : (str == "solid" ? line.style_solid : line.style_dashed)

// Fibonacci stuff
fiboBarWidth = input.int(2, minval=-1000, maxval=1000, title="Fibo width in bars", group="Fibonacci Axis", tooltip = "Due to the lack of scale/zoom detection, the width of the graduations is expressed in a multiplier of bar width")
fiboBarOffset = input.int(0, minval=-1000, maxval=1000, title="Offset to the right of the target window", group="Fibonacci Axis", tooltip="Due to the lack of scale/zoom detection, the axis is offseted from B Point by an amount of bar width")

// Ichimoku stuff
donchian(len) => math.avg(ta.lowest(len), ta.highest(len))
conversionPeriods = input.int(9, minval=1, title="Conversion Line Length", group="Ichimoku")
basePeriods = input.int(26, minval=1, title="Base Line Length", group="Ichimoku")
laggingSpan2Periods = input.int(52, minval=1, title="Leading Span B Length", group="Ichimoku")
displacement = input.int(26, minval=1, title="Lagging Span", group="Ichimoku")
conversionLine = donchian(conversionPeriods)
baseLine = donchian(basePeriods)
leadLine1 = math.avg(conversionLine, baseLine)
leadLine2 = donchian(laggingSpan2Periods)

// Tenkan crossovers with Kijun
crossoverUp = ta.crossover(conversionLine, baseLine)
crossoverDown = ta.crossunder(conversionLine, baseLine)

// Initialize variables for keeping track of crossover bars and distance last one
var int lastCrossBar = na
var int crossDistance = na
var int[] crossoverBars = array.new_int(0)
var int[] crossoverDist = array.new_int(0)

// Calculate distance in bars between crossovers
if crossoverUp or crossoverDown
    if not na(lastCrossBar)
        crossDistance := bar_index - lastCrossBar
        array.push(crossoverBars, bar_index)
        array.push(crossoverDist, crossDistance)
    lastCrossBar := bar_index

// EMA
len = input.int(200, minval=1, title="Length", group="Exponential Moving Average")
src = input(close, title="Source", group="Exponential Moving Average")
offset = input.int(title="Offset", defval=0, minval=-500, maxval=500, display = display.data_window, group="Exponential Moving Average")
typeMA = input.string(title = "Method", defval = "SMA", options=["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"], group="Exponential Moving Average", display = display.data_window)
smoothingLength = input.int(title = "Length", defval = 5, minval = 1, maxval = 100, group="Exponential Moving Average", display = display.data_window)

drawFiboLabel(int zeTime, float zePrice, string zeText, color bgColor, color txColor, string zeStyle) =>
    label.new(x=zeTime, y=zePrice, text=zeText, xloc=xloc.bar_time, yloc=yloc.price, color=bgColor, style=zeStyle, textcolor=txColor, size=size.normal)

drawTimeLabel(int zeTime, float zePrice, string zeText, color bgColor, color txColor, string zeStyle) =>
    label.new(x=zeTime, y=zePrice, text=zeText, xloc=xloc.bar_time, yloc=yloc.price, color=bgColor, style=zeStyle, textcolor=txColor, size=size.small)

drawArrowLabel(int zeTime, float zePrice, string zeText, color txColor) =>
    label.new(x=zeTime, y=zePrice, text=zeText, xloc=xloc.bar_time, yloc=yloc.price, color=priceLabelBgColor, style=label.style_label_left, textcolor=txColor)

drawTargetWindow(int time1, int time2, int time3, float bottomPrice, float topPrice) => 
    box.new(time1, topPrice, time3, bottomPrice, border_color = boxColorBCD, border_width = 1, border_style = line.style_dotted, xloc=xloc.bar_time, bgcolor=veilColor)
    line.new(time2, topPrice, time2, bottomPrice, xloc=xloc.bar_time, color=boxColorBCD, style=line.style_dotted, width = 1)

drawStrengthArrow(int timeOrigin, float priceOrigin, int targetTime, float targetPrice, string bigram, color arrowColor, int time1, int time3) => 
    line.new(timeOrigin, priceOrigin, targetTime, targetPrice, xloc = xloc.bar_time, color = arrowColor, style = line.style_arrow_right, width = 1)
    line.new(time1, targetPrice, time3, targetPrice, xloc = xloc.bar_time, color=arrowColor, style=line.style_dotted, width=1)
    label.new(time3, targetPrice, text=bigram + str.format(n4dig, targetPrice), xloc=xloc.bar_time, yloc=yloc.price, color=priceLabelBgColor, style=label.style_label_left, textcolor = arrowColor, size=size.small)

// Secondary Drawing function for extended features from BCD
drawIndicatorEx(Wave t) =>
    // retracement
    float retracement = math.abs((t.price3 - t.priceD) / (t.price3 - t.price2) * 100.0)
    // wave types
    bool nWave  = retracement <= pret ? true : false                                                                            // N Wave is a P Wave with less than 50% retracement (will tend to have E outside of BC)
    bool pWave  = retracement > pret and retracement < 100.0 ? true : false                                                     // P Wave is an N Wave with more than 50% retracement (will tend to have E staying inside of BC)
    bool sWave  = retracement >= 100.0 ? true : false                                                                           // S Wave is the premice of a Y Wave with more than 100% of retracement on BC
    // compute strengths
    float levelN = t.priceD + (t.price3 - t.price2)                                                                             // N:  
    float levelE = (t.price3 - t.price2) + t.price3                                                                             // E:  CE = BC
    float levelV = (t.price3 - t.priceD) + t.price3                                                                             // V:  DE = CD
    float levelNt = (t.priceD - t.price2) + t.priceD                                                                            // Nt: DE = BD (need 33% retracement of CD over BC)
    float levelP = (t.price2 - t.priceD) + t.price3                                                                             // P:  DE = C + (B - D)
    float levelY = (t.price2 - t.priceD) + t.price3                                                                             // Y:  DE = C + (B - D)
    float levelS = (t.price3 - t.price2) + t.priceD                                                                             // S:  DE = D + (C - B)
    float levelSm = (0.5 * (t.price3 - t.priceD)) + t.priceD                                                                    // Sm: DE = D + ((C - D) / 2)

    // compute polarity
    bool negativity = t.price2 > t.price3                                                                                       // (C-B) < 0   (B is higher than C)
    // compute timeEx1, timeEx2, timeEx3
    int time2 = t.timeD + (t.time3 - t.time2)
    int time1 = time2 - (t.time3 - t.time2 - candleTime)
    int time3 = time2 + (t.time3 - t.time2 - candleTime)
    // compute top and bottom
    float levelTop = sWave ? levelY : levelE                                                                                    // Y if S-Wave or (E if N-Wave|P-Wave)
    float levelBottom = t.priceD
    // draw box and median time
    drawTargetWindow(time1, time2, time3, levelBottom, levelTop)
    // draw arrows, level, labels as one object call
    if nWave or pWave
        drawStrengthArrow(t.timeD, t.priceD, time2, levelN, "N= ", arrowColorNS, time1, time3)
        drawStrengthArrow(t.timeD, t.priceD, time2, levelE, "E= ", arrowColorEY, time1, time3)
        drawStrengthArrow(t.timeD, t.priceD, time2, levelV, "V= ", arrowColorVSm, time1, time3)
        if pWave
            drawStrengthArrow(t.timeD, t.priceD, time2, levelP, "P= ", arrowColorNtP, time1, time3)
        else
            drawStrengthArrow(t.timeD, t.priceD, time2, levelNt, "Nt= ", arrowColorNtP, time1, time3)

    if sWave
        drawStrengthArrow(t.timeD, t.priceD, time2, levelS, "S= ", arrowColorNS, time1, time3)
        drawStrengthArrow(t.timeD, t.priceD, time2, levelY, "Y= ", arrowColorEY, time1, time3)
        drawStrengthArrow(t.timeD, t.priceD, time2, levelSm, "Sm= ", arrowColorVSm, time1, time3)

// Main Drawing function using Wave theory about N Waves with Undulatory by Hosoda
drawIndicator(Wave t) =>

    if wavt
        // Wave lines, Box and Arrows
        line.new(t.time1, t.price1, t.time2, t.price2, xloc = xloc.bar_time, color = wavc, width=wavw, style=lineStr2style(wavs))                                                                                   // dotted impulse
        line.new(t.time2, t.price2, t.time3, t.price3, xloc = xloc.bar_time, color = wavc, width=wavw, style=lineStr2style(wavs))                                                                                   // dotted correction
        line.new(t.time3, t.price3, t.timeD, t.priceD, xloc = xloc.bar_time, color = wavc, width=wavw, style=lineStr2style(wavs))                                                                                   // dotted D wave

    // Extends to deadline or time4
    int deadline = tim3 ? t.boxTime1 : t.time4

    if t.nWave or t.pWave
        // arrows
        line.new(t.time3, t.price3, deadline, tim3 ? t.price4Ex : t.price3 + t.priceDelta1, xloc = xloc.bar_time, color = arrowColorNS, width=1, style=line.style_arrow_right)                                    // orange arrow N (prime)        C+(B-A)
        line.new(t.time3, t.price3, deadline, tim3 ? t.boxEPriceEx : t.boxTopPrice, xloc = xloc.bar_time, color = arrowColorEY, width=1, style=line.style_arrow_right)                                            // blue arrow E (highest/lowest) B+(B-A)
        line.new(t.time3, t.price3, deadline, tim3 ? t.boxVPriceEx : t.boxVPrice, xloc = xloc.bar_time, color = arrowColorVSm, width=1, style=line.style_arrow_right)                                             // red arrow V      B+(B-C)
        if t.pWave == false
            line.new(t.time3, t.price3, deadline, tim3 ? t.boxNtPriceEx : t.boxNtPrice, xloc = xloc.bar_time, color = arrowColorNtP, width=1, style=line.style_arrow_right)                                       // green arrow Nt   C+(C-A)
        if t.pWave
            line.new(t.time3, t.price3, deadline, tim3 ? t.boxPPriceEx : t.boxPPrice, xloc = xloc.bar_time, color = arrowColorNtP, width=1, style=line.style_arrow_right)                                         // green arrow P
        // levels
        line.new(t.boxTime0, tim3 ? t.price4Ex : t.price4, t.boxTime1, tim3 ? t.price4Ex : t.price4, xloc = xloc.bar_time, color = arrowColorNS, width=1, style=line.style_dotted)                                // level N
        line.new(t.boxTime0, tim3 ? t.boxEPriceEx : t.boxTopPrice, t.boxTime1, tim3 ? t.boxEPriceEx : t.boxTopPrice, xloc = xloc.bar_time, color = arrowColorEY, width=1, style=line.style_dotted)                // level E
        line.new(t.boxTime0, tim3 ? t.boxVPriceEx : t.boxVPrice, t.boxTime1, tim3 ? t.boxVPriceEx : t.boxVPrice, xloc = xloc.bar_time, color = arrowColorVSm, width=1, style=line.style_dotted)                   // level V
        if t.pWave == false
            line.new(t.boxTime0, tim3 ? t.boxNtPriceEx : t.boxNtPrice, t.boxTime1, tim3 ? t.boxNtPriceEx : t.boxNtPrice, xloc = xloc.bar_time, color = arrowColorNtP, width=1, style=line.style_dotted)           // level Nt
        if t.pWave
            line.new(t.boxTime0, tim3 ? t.boxPPriceEx : t.boxPPrice, t.boxTime1, tim3 ? t.boxPPriceEx : t.boxPPrice, xloc = xloc.bar_time, color = arrowColorNtP, width=1, style=line.style_dotted)               // level P (prime)

    if t.sWave
        // arrows
        line.new(t.time3, t.price3, deadline, tim3 ? t.boxSPriceEx : t.boxSPrice, xloc = xloc.bar_time, color = arrowColorNS, width=1, style=line.style_arrow_right)                                              // orange arrow S (prime)
        line.new(t.time3, t.price3, deadline, tim3 ? t.boxYPriceEx : t.boxYPrice, xloc = xloc.bar_time, color = arrowColorEY, width=1, style=line.style_arrow_right)                                              // blue arrow Y (highest/lowest)
        line.new(t.time3, t.price3, deadline, tim3 ? t.boxSmPriceEx : t.boxSmPrice, xloc = xloc.bar_time, color = arrowColorVSm, width=1, style=line.style_arrow_right)                                           // red arrow Sm (median)
        // levels
        line.new(t.boxTime0, tim3 ? t.boxSPriceEx : t.boxSPrice, t.boxTime1, tim3 ? t.boxSPriceEx : t.boxSPrice, xloc = xloc.bar_time, color = arrowColorNS, width=1, style=line.style_dotted)                    // level S
        line.new(t.boxTime0, tim3 ? t.boxYPriceEx : t.boxYPrice, t.boxTime1, tim3 ? t.boxYPriceEx : t.boxYPrice, xloc = xloc.bar_time, color = arrowColorEY, width=1, style=line.style_dotted)                    // level Y
        line.new(t.boxTime0, tim3 ? t.boxSmPriceEx : t.boxSmPrice, t.boxTime1, tim3 ? t.boxSmPriceEx : t.boxSmPrice, xloc = xloc.bar_time, color = arrowColorVSm, width=1, style=line.style_dotted)               // level Sm

    if ac26
        int candleTime25x = 25 * candleTime
        int time1plus26 = t.time1 + candleTime25x
        int time3plus26 = t.time3 + candleTime25x
        float highest = math.max(t.price1, t.price2, t.price3, t.priceD, t.boxTopPrice)
        float lowest = math.min(t.price1, t.price2, t.price3, t.priceD, t.boxTopPrice)
        line.new(time1plus26, highest, time1plus26, lowest, xloc = xloc.bar_time, color = color.orange, width=1, style=line.style_dotted)                                                                           // time A + 26 periods
        line.new(time3plus26, highest, time3plus26, lowest, xloc = xloc.bar_time, color = color.orange, width=1, style=line.style_dotted)                                                                           // time C + 26 periods

    if mult
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice2, xloc = xloc.bar_time, color = arrowColorEY, width=1, style=line.style_arrow_right)                                                    // blue arrow 2Y (highest)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice2 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = arrowColorNS, width=1, style=line.style_arrow_right)                       // orange arrow 2S (prime)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice3, xloc = xloc.bar_time, color = arrowColorEY, width=1, style=line.style_arrow_right)                                                    // blue arrow 3Y (highest)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice3 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = arrowColorNS, width=1, style=line.style_arrow_right)                       // orange arrow 3S (prime)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice4, xloc = xloc.bar_time, color = arrowColorEY, width=1, style=line.style_arrow_right)                                                    // blue arrow 4Y (highest)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice4 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = arrowColorNS, width=1, style=line.style_arrow_right)                       // orange arrow 4S (prime)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice5, xloc = xloc.bar_time, color = arrowColorEY, width=1, style=line.style_arrow_right)                                                    // blue arrow 5Y (highest)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice5 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = arrowColorNS, width=1, style=line.style_arrow_right)                       // orange arrow 5S (prime)
        line.new(t.boxTime0, t.boxTopPrice2 - (t.boxTopPrice - t.price4), t.boxTime1, t.boxTopPrice2 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = arrowColorNS, width=1, style=line.style_dotted)  // level 2S
        line.new(t.boxTime0, t.boxTopPrice2, t.boxTime1, t.boxTopPrice2, xloc = xloc.bar_time, color = arrowColorEY, width=1, style=line.style_dotted)                                                            // level 2Y
        line.new(t.boxTime0, t.boxTopPrice3 - (t.boxTopPrice - t.price4), t.boxTime1, t.boxTopPrice3 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = arrowColorNS, width=1, style=line.style_dotted)  // level 3S
        line.new(t.boxTime0, t.boxTopPrice3, t.boxTime1, t.boxTopPrice3, xloc = xloc.bar_time, color = arrowColorEY, width=1, style=line.style_dotted)                                                            // level 3Y
        line.new(t.boxTime0, t.boxTopPrice4 - (t.boxTopPrice - t.price4), t.boxTime1, t.boxTopPrice4 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = arrowColorNS, width=1, style=line.style_dotted)  // level 4S
        line.new(t.boxTime0, t.boxTopPrice4, t.boxTime1, t.boxTopPrice4, xloc = xloc.bar_time, color = arrowColorEY, width=1, style=line.style_dotted)                                                            // level 4Y
        line.new(t.boxTime0, t.boxTopPrice5 - (t.boxTopPrice - t.price4), t.boxTime1, t.boxTopPrice5 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = arrowColorNS, width=1, style=line.style_dotted)  // level 5S
        line.new(t.boxTime0, t.boxTopPrice5, t.boxTime1, t.boxTopPrice5, xloc = xloc.bar_time, color = arrowColorEY, width=1, style=line.style_dotted)                                                            // level 5Y

    line.new(t.time3 + t.timeDelta2, t.price3, t.time3 + t.timeDelta2, t.boxTopPrice, xloc = xloc.bar_time, color = arrowColorVSm, width=1, style=line.style_dashed)                                              // dashed at double correction time

    box.new(t.boxTime0, t.boxTopPrice, t.boxTime1, t.price3, border_color = color.teal, border_width = 1, border_style = line.style_solid, bgcolor = veilColor, xloc=xloc.bar_time)                                        // target box deadline
    line.new(t.time3 + t.timeDelta1, t.boxTopPrice, t.time3 + t.timeDelta1, t.price3, xloc=xloc.bar_time, style = line.style_dashed, width = 1, color=color.teal)                                                   // target dashed dateline

    // toggle the direction of things considering the relation between time A and time B
    var styleABC = label.style_label_up
    var styleABC2 = label.style_label_down
    var styleRetrac = label.style_label_up
    if t.price2 < t.price1
        styleABC := label.style_label_down
        styleABC2 := label.style_label_up
        styleRetrac := label.style_label_down

    // Point Colors
    pointTextColor = color.black
    pointFillColor = color.rgb(105, 155, 255)

    // Wave labels
    var textA = "A" + (labp ? "\n" + str.format(n2dig, t.price1) : "")
    var textB = "B\n" + str.format(n3pad, 1 + ((t.time2 - t.time1) / candleTime)) + (labp ? "\n" + str.format(n2dig, t.price2) : "")
    var textC = "C\n" + str.format(n3pad, 1 + ((t.time3 - t.time1 + 1.001) / candleTime)) + (labp ? "\n" + str.format(n2dig, t.price3) : "")
    label.new(t.time1, t.price1, textA, xloc.bar_time, yloc.price, pointFillColor, styleABC, pointTextColor, size.small, text.align_center)
    label.new(t.time2, t.price2, textB, xloc.bar_time, yloc.price, pointFillColor, styleABC2, pointTextColor, size.small, text.align_center)
    label.new(t.time3, t.price3, textC, xloc.bar_time, yloc.price, pointFillColor, styleABC, pointTextColor, size.small, text.align_center)

    // Compute tenth (deciles) of the box duration
    priceDeci = (t.price4 - t.price3) / 10
    timeDeci = (t.boxTime1 - t.boxTime0) / 10
    
    // Retracement of C over BA
    label.new(x=math.floor(t.time2 + (t.time3 - t.time2)), y=t.baNegative ? t.price2 + (1.8 * math.abs(t.price3 - t.price2)) : t.price2 - (1.8 * math.abs(t.price2 - t.price3)), text="retracement BC: " + str.format(n2dig, t.retracement) + "%", xloc=xloc.bar_time, yloc=yloc.price, color=retracementBgColor, style=styleRetrac, textcolor=color.white)

    // Box date labels
    drawTimeLabel(t.time4,    t.price3,      str.format_time(t.time4,    stamp, "UTC+" + str.tostring(timeZone)), timeColor,       goldColor,        t.baNegative ? label.style_label_down : label.style_label_up)
    drawTimeLabel(t.boxTime0, t.boxTopPrice, str.format_time(t.boxTime0, stamp, "UTC+" + str.tostring(timeZone)), transpTimeColor, transpWhiteColor, t.baNegative ? label.style_label_up : label.style_label_down)
    drawTimeLabel(t.boxTime1, t.boxTopPrice, str.format_time(t.boxTime1, stamp, "UTC+" + str.tostring(timeZone)), transpTimeColor, transpWhiteColor, t.baNegative ? label.style_label_up : label.style_label_down)

    // Arrow Labels
    if t.sWave == false
        drawArrowLabel(t.boxTime1, tim3 ? t.price4Ex : t.price4,            "N=" + str.format(n4dig, tim3 ? t.price4Ex : t.price4),             arrowColorNS)
        drawArrowLabel(t.boxTime1, tim3 ? t.boxEPriceEx : t.boxEPrice,      "E=" + str.format(n4dig, tim3 ? t.boxEPriceEx : t.boxEPrice),       arrowColorEY)
        drawArrowLabel(t.boxTime1, tim3 ? t.boxVPriceEx : t.boxVPrice,      "V=" + str.format(n4dig, tim3 ? t.boxVPriceEx : t.boxVPrice),       arrowColorVSm)

    if t.pWave == false and t.sWave == false
        drawArrowLabel(t.boxTime1, tim3 ? t.boxNtPriceEx : t.boxNtPrice,    "Nt=" + str.format(n4dig, tim3 ? t.boxNtPriceEx : t.boxNtPrice),    arrowColorNtP)

    if t.pWave
        drawArrowLabel(t.boxTime1, tim3 ? t.boxPPriceEx : t.boxPPrice,      "P=" + str.format(n4dig, tim3 ? t.boxPPriceEx : t.boxPPrice),       arrowColorNtP)

    if t.sWave
        drawArrowLabel(t.boxTime1, tim3 ? t.boxYPriceEx : t.boxYPrice,      "Y=" + str.format(n4dig, tim3 ? t.boxYPriceEx : t.boxYPrice),       arrowColorEY)
        drawArrowLabel(t.boxTime1, tim3 ? t.boxSPriceEx : t.boxSPrice,      "S=" + str.format(n4dig, tim3 ? t.boxSPriceEx : t.boxSPrice),       arrowColorNS)
        drawArrowLabel(t.boxTime1, tim3 ? t.boxSmPriceEx : t.boxSmPrice,    "Sm=" + str.format(n4dig, tim3 ? t.boxSmPriceEx : t.boxSmPrice),    arrowColorVSm)

    if mult
        float deltaPrice4toTop = (t.boxTopPrice - t.price4)
        drawArrowLabel(t.boxTime1, t.boxTopPrice2,                          (t.sWave ? "2Y=" : "2E=") + str.format(n4dig, t.boxTopPrice2),                          arrowColorEY)
        drawArrowLabel(t.boxTime1, t.boxTopPrice2 - deltaPrice4toTop,       (t.sWave ? "2S=" : "2N=") + str.format(n4dig, t.boxTopPrice2 - deltaPrice4toTop),       arrowColorNS)
        drawArrowLabel(t.boxTime1, t.boxTopPrice3,                          (t.sWave ? "3Y=" : "3E=") + str.format(n4dig, t.boxTopPrice3),                          arrowColorEY)
        drawArrowLabel(t.boxTime1, t.boxTopPrice3 - deltaPrice4toTop,       (t.sWave ? "3S=" : "3N=") + str.format(n4dig, t.boxTopPrice3 - deltaPrice4toTop),       arrowColorNS)
        drawArrowLabel(t.boxTime1, t.boxTopPrice4,                          (t.sWave ? "4Y=" : "4E=") + str.format(n4dig, t.boxTopPrice4),                          arrowColorEY)
        drawArrowLabel(t.boxTime1, t.boxTopPrice4 - deltaPrice4toTop,       (t.sWave ? "4S=" : "4N=") + str.format(n4dig, t.boxTopPrice4 - deltaPrice4toTop),       arrowColorNS)
        drawArrowLabel(t.boxTime1, t.boxTopPrice5,                          (t.sWave ? "5Y=" : "5E=") + str.format(n4dig, t.boxTopPrice5),                          arrowColorEY)
        drawArrowLabel(t.boxTime1, t.boxTopPrice5 - deltaPrice4toTop,       (t.sWave ? "5S=" : "5N=") + str.format(n4dig, t.boxTopPrice5 - deltaPrice4toTop),       arrowColorNS)

    // Point D is only labeled if positionned after Time C
    if t.timeD > t.time3
        label.new(t.timeD, t.priceD, "D\n" + str.format(n3pad, 1 + ((t.timeD - t.time1) / candleTime)) + (labp ? "\n" + str.format(n4dig, t.priceD) : ""), xloc.bar_time, yloc.price, pointFillColor, styleABC2, pointTextColor, size.small, text.align_center)
        // Trendlines are drawable since D is visible
        if tren
            line.new(t.time1, t.price1, t.time3, t.price3, xloc=xloc.bar_time, color=tcol, style = line.style_solid, width=twid, extend = extend.both)
            line.new(t.time2, t.price2, t.timeD, t.priceD, xloc=xloc.bar_time, color=tcol, style = line.style_solid, width=twid, extend = extend.both)

        // Extended strength arrows from BCD
        if bcd4
            drawIndicatorEx(t)

    // E-Box: If Point D has been placed after Point C, we have some prediction to make
    if ebox and t.timeD > t.time3
        box.new(t.boxTimeE0, t.boxPriceEBot, t.boxTimeE1, t.boxPriceETop, bgcolor = veilColor, border_color = ecol, xloc = xloc.bar_time, border_width = 1)
        line.new(t.timeD, t.priceD, t.boxTimeE0, t.boxPriceEAnchor, xloc=xloc.bar_time, color=ecol, style = line.style_arrow_right, width=1)
        line.new(t.timeD, t.priceD, t.boxTimeE1, t.boxPriceEAnchor, xloc=xloc.bar_time, color=ecol, style = line.style_arrow_right, width=1)
        drawArrowLabel(t.boxTimeE1, t.boxPriceETop, str.format(n4dig, t.boxPriceETop), ecol)
        drawArrowLabel(t.boxTimeE1, t.boxPriceEBot, str.format(n4dig, t.boxPriceEBot), ecol)
        drawTimeLabel(t.boxTimeE0, t.boxPriceELabels, str.format_time(t.boxTimeE0, stamp, "UTC+" + str.tostring(timeZone)), transpTimeColor, transpWhiteColor, t.priceD < t.boxPriceELabels ? label.style_label_down : label.style_label_up)
        drawTimeLabel(t.boxTimeE1, t.boxPriceELabels, str.format_time(t.boxTimeE1, stamp, "UTC+" + str.tostring(timeZone)), transpTimeColor, transpWhiteColor, t.priceD < t.boxPriceELabels ? label.style_label_down : label.style_label_up)

    if (ksob or ksoc) and kisu == false
        int fromPoint = ksoc ? t.time3 - candleTime : t.time2 - candleTime
        int[] cycles = array.from(0,9,17,26,33,42,51,65,76,83,97,101,151,226)
        for i = array.size(cycles) - 1 to 0
            if array.get(cycles, i) <= ksmx 
                cycle = (array.get(cycles, i) * candleTime) + fromPoint + (candleTime * ksof)
                if i > 0
                    line.new(cycle, math.min(y1Input, y2Input, y3Input), cycle, math.max(y1Input, y2Input, y3Input), xloc.bar_time, extend.both, color.rgb(33, 149, 243, 50), line.style_dotted, 2)
                label.new(cycle, t.price2, str.format(n2pad, array.get(cycles, i)), xloc.bar_time, yloc.price, color.rgb(27, 32, 36, 100), label.style_label_left, color.blue )

    if tasu
        string txtCorr = "Wave ABC is not correlated"
        bool corr = false
        int[] naturalCycles = array.from(25,26,27)
        int ab = t.timeDelta1 / candleTime
        int bc = t.timeDelta2 / candleTime
        int cd = t.timeDelta3 / candleTime
        int abc = ab + bc + 1
        int bcd = (t.timeD > t.time3) ? bc + cd + 1 : na
        // log.info(str.tostring(bcd))
        for i = array.size(naturalCycles) - 1 to 0
            if array.get(naturalCycles, i) == abc or array.get(naturalCycles, i) == bcd
                corr := true
                txtCorr := "Wave ABC is natural"
                break
        if corr == false
            int[] kisuCycles = array.from(9,17,33,42,51,65,76,83,97,101,151,226)
            for i = array.size(kisuCycles) - 1 to 0
                if array.get(kisuCycles, i) == abc or array.get(kisuCycles, i) == bcd
                    corr := true
                    txtCorr := "Wave ABC is correlated"
                    break
            if corr == false
                for i = array.size(kisuCycles) - 1 to 0
                    if array.get(kisuCycles, i)-1 == abc or array.get(kisuCycles, i)-1 == bcd or array.get(kisuCycles, i)+1 == abc or array.get(kisuCycles, i)+1 == bcd
                        corr := true
                        txtCorr := "Wave ABC is +1/-1 correlated"
                        break
        color colCorr = corr ? color.lime : color.red
        table.cell(tabCorr, 0, 0, txtCorr, 10, 3, text_color = color.white, text_size = size.small, bgcolor = colCorr)
        if ab == bc or bc == cd
            table.cell(tabTasu, 0, 0, "Taito Suchi of " + str.tostring(ab==bc ? ab : bc), 5, 3, text_color = color.yellow, text_size = size.small, bgcolor = color.maroon)

    if fibo
        var offsetXFiboM = (candleTime * fiboBarOffset) + t.time2
        var offsetXFiboL = offsetXFiboM - (candleTime * fiboBarWidth)
        var offsetXFiboR = offsetXFiboM + (candleTime * fiboBarWidth)

        // Positive Scale
        float fractionPos = ((t.price4 - t.price3) / 100)
        line.new(t.time3, t.price3, offsetXFiboR, t.price3, xloc = xloc.bar_time, color = fiboZeroColor, width=1, style=line.style_dotted)    // 0%
        drawFiboLabel(offsetXFiboR, t.price3, "    0 %", transparent, labelFiboTextColor, label.style_label_left)

        var fibo23 = 23.6 * fractionPos + t.price3
        line.new(offsetXFiboM, fibo23, offsetXFiboR, fibo23, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 23.6%
        drawFiboLabel(offsetXFiboR, fibo23, "23.6 %", transparent, labelFiboTextColor, label.style_label_left)

        var fibo38 = 38.2 * fractionPos + t.price3
        line.new(offsetXFiboM, fibo38, offsetXFiboR, fibo38, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 38.2%
        drawFiboLabel(offsetXFiboR, fibo38, "38.2 %", transparent, labelFiboTextColor, label.style_label_left)

        var fibo50 = 50.0 * fractionPos + t.price3
        line.new(offsetXFiboM, fibo50, offsetXFiboR, fibo50, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 50.0%
        drawFiboLabel(offsetXFiboR, fibo50, "50.0 %", transparent, labelFiboTextColor, label.style_label_left)

        var fibo61 = 61.8 * fractionPos + t.price3
        line.new(offsetXFiboM, fibo61, offsetXFiboR, fibo61, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 61.8%
        drawFiboLabel(offsetXFiboR, fibo61, "61.8 %", transparent, labelFiboTextColor, label.style_label_left)

        var fibo78 = 78.6 * fractionPos + t.price3
        line.new(offsetXFiboM, fibo78, offsetXFiboR, fibo78, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 78.6%
        drawFiboLabel(offsetXFiboR, fibo78, "78.6 %", transparent, labelFiboTextColor, label.style_label_left)

        line.new(offsetXFiboM, t.price4, offsetXFiboR, t.price4, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 100%
        drawFiboLabel(offsetXFiboR, t.price4, " 100 %", transparent, labelFiboTextColorGoal, label.style_label_left)

        var fibo123 = 123.6 * fractionPos + t.price3
        line.new(offsetXFiboM, fibo123, offsetXFiboR, fibo123, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 123%
        drawFiboLabel(offsetXFiboR, fibo123, " 123 %", transparent, labelFiboTextColorGoal, label.style_label_left)

        var fibo138 = 138.2 * fractionPos + t.price3
        line.new(offsetXFiboM, fibo138, offsetXFiboR, fibo138, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 138%
        drawFiboLabel(offsetXFiboR, fibo138, " 138 %", transparent, labelFiboTextColorGoal, label.style_label_left)

        var fibo161 = 161.8 * fractionPos + t.price3
        line.new(offsetXFiboM, fibo161, offsetXFiboR, fibo161, xloc = xloc.bar_time, color = labelFiboTextColorGold, width=1, style=line.style_solid)    // 161%
        drawFiboLabel(offsetXFiboR, fibo161, " 161 %", transparent, labelFiboTextColorGold, label.style_label_left)

        var fibo178 = 178.4 * fractionPos + t.price3
        line.new(offsetXFiboM, fibo178, offsetXFiboR, fibo178, xloc = xloc.bar_time, color = labelFiboTextColorGold, width=1, style=line.style_solid)    // 178%
        drawFiboLabel(offsetXFiboR, fibo178, " 178 %", transparent, labelFiboTextColorGold, label.style_label_left)

        var fibo200 = 200.0 * fractionPos + t.price3
        line.new(offsetXFiboM, fibo200, offsetXFiboR, fibo200, xloc = xloc.bar_time, color = labelFiboTextColorGold, width=1, style=line.style_solid)    // 200%
        drawFiboLabel(offsetXFiboR, fibo200, " 200 %", transparent, labelFiboTextColorGold, label.style_label_left)

        // Negative scale
        float fraction = ((t.price2 - t.price1) / 100)
        line.new(offsetXFiboL, t.price2, offsetXFiboM, t.price2, xloc = xloc.bar_time, color = labelFiboTextColorNeg, width=1, style=line.style_solid)    // -0% at B
        drawFiboLabel(offsetXFiboL, t.price2, "-0 %", transparent, labelFiboTextColorNeg, label.style_label_right)

        var fiboN23 = -23.6 * fraction + t.price2
        line.new(offsetXFiboL, fiboN23, offsetXFiboM, fiboN23, xloc = xloc.bar_time, color = labelFiboTextColorNeg, width=1, style=line.style_solid)    // -23.6%
        drawFiboLabel(offsetXFiboL, fiboN23, "-23.6 %", transparent, labelFiboTextColorNeg, label.style_label_right)

        var fiboN38 = -38.2 * fraction + t.price2
        line.new(offsetXFiboL, fiboN38, offsetXFiboM, fiboN38, xloc = xloc.bar_time, color = labelFiboTextColorNeg, width=1, style=line.style_solid)    // -38.2%
        drawFiboLabel(offsetXFiboL, fiboN38, "-38.2 %", transparent, labelFiboTextColorNeg, label.style_label_right)

        var fiboN50 = -50.0 * fraction + t.price2
        line.new(offsetXFiboL, fiboN50, offsetXFiboM, fiboN50, xloc = xloc.bar_time, color = labelFiboTextColorNeg, width=1, style=line.style_solid)    // -50.0%
        drawFiboLabel(offsetXFiboL, fiboN50, "-50.0 %", transparent, labelFiboTextColorNeg, label.style_label_right)

        var fiboN61 = -61.8 * fraction + t.price2
        line.new(offsetXFiboL, fiboN61, offsetXFiboM, fiboN61, xloc = xloc.bar_time, color = labelFiboTextColorNeg, width=1, style=line.style_solid)    // -61.8%
        drawFiboLabel(offsetXFiboL, fiboN61, "-61.8 %", transparent, labelFiboTextColorNeg, label.style_label_right)

        var fiboN78 = -78.6 * fraction + t.price2
        line.new(offsetXFiboL, fiboN78, offsetXFiboM, fiboN78, xloc = xloc.bar_time, color = labelFiboTextColorNeg, width=1, style=line.style_solid)    // -78.6%
        drawFiboLabel(offsetXFiboL, fiboN78, "-78.6 %", transparent, labelFiboTextColorNeg, label.style_label_right)

        line.new(offsetXFiboL, t.price1, offsetXFiboM, t.price1, xloc = xloc.bar_time, color = labelFiboTextColorNegCrash, width=1, style=line.style_solid)    // -100%
        drawFiboLabel(offsetXFiboL, t.price1, "-100 %", transparent, labelFiboTextColorNegCrash, label.style_label_right)

        var topAxis = math.max(t.price1, t.price2, fibo200, t.price3)
        var botAxis = math.min(t.price1, t.price2, fibo200, t.price3)
        line.new(offsetXFiboM, botAxis, offsetXFiboM, topAxis, xloc = xloc.bar_time, color = fiboAxisColor, width=1, style=line.style_solid)   // vertical scale axis
        
formatPrice(float predi) =>
    str.tostring(predi, format.volume)

drawCtoN(Wave t) =>
    float ratioNAB = 0.0
    int offsetXFiboM = (candleTime * fiboBarOffset) + t.time2
    float ratioN = 100.0 * ((t.price4-t.price3) / t.price3)
    float ratioC = 100.0 * math.abs((t.currentPrice-t.price3) / t.price3) * (t.baNegative ? -1 : 1)
    if t.currentPrice > t.price2
        ratioNAB := t.baNegative ? -100.0 * math.abs((t.price2-t.currentPrice)/(t.price1-t.price2)) : 100.0 * math.abs((t.currentPrice-t.price3)/(t.price4-t.price3))
    else
        ratioNAB := t.baNegative ? 100.0 * math.abs((t.currentPrice-t.price3)/(t.price4-t.price3)) : -100.0 * math.abs((t.price2-t.currentPrice)/(t.price1-t.price2))
    string sratioN = '100% = ' + (ratioN < 0 ? '': '+') + str.format(n2dig, ratioN) + ' % C TO N/S'
    string sratioC = (ratioC < 0 ? '': '+') + str.format(n2dig, ratioC) + ' %'
    string sratioNAB = (ratioNAB < 0 ? '' : '+') + str.format(n2dig, ratioNAB) + ' %'
    label.new(offsetXFiboM, t.price4, sratioN, xloc.bar_time, yloc.price, color.rgb(255, 153, 0), label.style_label_left, color.rgb(0, 0, 0), size.normal, text.align_center, '', font.family_monospace)
    var labelRatioC = label.new(offsetXFiboM, t.currentPrice, sratioC, xloc.bar_time, yloc.price, color.rgb(96,96,96), label.style_label_right, color.rgb(255, 255, 255), size.normal, text.align_center, '', font.family_monospace)
    var labelRatioNAB = label.new(offsetXFiboM, t.currentPrice, sratioNAB, xloc.bar_time, yloc.price, color.rgb(38,166,154), label.style_label_left, color.rgb(255, 255, 255), size.normal, text.align_center, '', font.family_monospace)
    if (t.baNegative == false and t.currentPrice <= t.price2) or (t.baNegative and t.currentPrice >= t.price2)
        labelRatioC.set_style(label.style_label_left)
        labelRatioNAB.set_style(label.style_label_right)
        labelRatioNAB.set_color(color.rgb(255, 82, 82))

drawSLP(Wave t) =>
    
    // Stupid Linear Prediction
    var nBarOvershoot = 5
    var predi = t.price3 + ((t.currentPrice - t.price3)*(t.time4 - t.time3))/(t.currentTime - t.time3)
    var timeAtOvershoot = t.time4 //t.currentTime + (nBarOvershoot * candleTime)
    var slpPrice = t.price3 + ((t.currentPrice - t.price3)*(timeAtOvershoot - t.time3))/(t.currentTime - t.time3)

    label.new(t.currentTime, na, "SLP=" + formatPrice(predi), xloc.bar_time, yloc.abovebar, color.rgb(132, 0, 255), label.style_label_lower_left, size=size.small, textcolor = color.rgb(255, 255, 255), textalign = text.align_center)
    line.new(t.currentTime, t.currentPrice, timeAtOvershoot, slpPrice, xloc=xloc.bar_time, color=color.purple, style=line.style_arrow_right, width=1)
    
if barstate.isrealtime and not barstate.isconfirmed

    Wave wave = Wave.new()

    wave.price1 := y1Input
    wave.price2 := y2Input
    wave.baNegative := wave.price1 > wave.price2
    wave.time2 := x2Input    
    wave.time3  := x3Input
    wave.price3 := y3Input
    wave.price4 := y3Input + (y2Input - y1Input)
    wave.time4  := x3Input + (x2Input - x1Input)

    wave.currentPrice := close //barstate.islastconfirmedhistory ? close : 1
    wave.currentTime := time //barstate.islastconfirmedhistory ? time : wave.time3
    
    if cton
        drawCtoN(wave)

    if tend and wave.time4 > wave.currentTime
        drawSLP(wave)

closestLevelS(bool baNegative, float d, float sm, float s, float y) => 
    float level = 0
    if baNegative == false
        if d>sm
            level := d-sm
        if d>s
            level := d-s
        if d>y
            level := d-y
    if baNegative
        if d<sm
            level := sm-d
        if d<s
            level := s-d
        if d<y
            level := y-d
    level

closestLevelN(bool baNegative, float d, float ntp, float n, float e, float n2, float e2, float n3, float e3, float n4, float e4) => 
    float level = 0
    if baNegative == false
        if d>ntp
            level := d-ntp
        if d>n
            level := d-n
        if d>e
            level := d-e
        if d>n2
            level := d-n2
        if d>e2
            level := d-e2
        if d>n3
            level := d-n3
        if d>e3
            level := d-e3
        if d>n4
            level := d-n4
        if d>e4
            level := d-e4
    if baNegative
        if d<ntp
            level := ntp-d
        if d<n
            level := n-d
        if d<e
            level := e-d
        if d<n2
            level := n2-d
        if d<e2
            level := e2-d
        if d<n3
            level := n3-d
        if d<e3
            level := e3-d
        if d<n4
            level := n4-d
        if d<e4
            level := e4-d
    level

// Draw the indicator on next confirmed tick
if barstate.islastconfirmedhistory

    Wave wave = Wave.new()

    wave.time1  := x1Input
    wave.time2  := x2Input
    wave.time3  := x3Input
    wave.time4  := x3Input + (x2Input - x1Input)
    wave.timeD  := x4Input
    wave.price1 := y1Input
    wave.price2 := y2Input
    wave.price3 := y3Input
    wave.price4 := y3Input + (y2Input - y1Input)                                                                              // N:   
    wave.priceD := y4Input
    wave.baNegative := wave.price1 > wave.price2                                                                              // (B-A) < 0   (A is higher than B)
    wave.retracement := math.abs((wave.price2 - wave.price3) / (wave.price2 - wave.price1) * 100.0)
    wave.nWave  := wave.retracement <= pret ? true : false                                                        // N Wave is a P Wave with less than 50% retracement (will tend to have D outside of AB)
    wave.pWave  := wave.retracement > pret and wave.retracement < 100.0 ? true : false                            // P Wave is an N Wave with more than 50% retracement (will tend to have D staying inside of AB)
    wave.sWave  := wave.retracement >= 100.0 ? true : false                                                                   // S Wave is the premice of a Y Wave with more than 100% of retracement on AB
    wave.priceDelta1 := y2Input - y1Input
    wave.priceDelta2 := y3Input - y2Input
    wave.timeDelta1 := x2Input - x1Input
    wave.timeDelta2 := x3Input - x2Input
    wave.timeDelta3 := x4Input - x3Input
    wave.boxTime0 := wave.time4 - wave.timeDelta2
    wave.boxTime1 := wave.time4 + wave.timeDelta2
    wave.boxEPrice := (wave.price2 - wave.price1) + wave.price2                                                                 // E:  BD = AB
    wave.boxVPrice := (wave.price2 - wave.price3) + wave.price2                                                                 // V:  CD = BC
    wave.boxNtPrice := (wave.price3 - wave.price1) + wave.price3                                                                // Nt: CD = AC (need 33% retracement of BC over AB)
    wave.boxPPrice := (wave.price1 - wave.price3) + wave.price2                                                                 // P:  CD = B + (A - C)
    wave.boxYPrice := (wave.price1 - wave.price3) + wave.price2                                                                 // Y:  CD = B + (A - C)
    wave.boxSPrice := (wave.price2 - wave.price1) + wave.price3                                                                 // S:  CD = C + (B - A)
    wave.boxSmPrice := (0.5 * (wave.price2 - wave.price3)) + wave.price3                                                        // Sm: CD = C + ((B - C) / 2)
    wave.boxTopPrice := wave.sWave ? wave.boxYPrice : wave.boxEPrice                                                            // Y if S-Wave or (E if N-Wave|P-Wave)
    wave.boxTopPrice2 := 2 * (wave.price4 - wave.price3) + (wave.boxTopPrice - wave.price4) + wave.price3
    wave.boxTopPrice3 := 3 * (wave.price4 - wave.price3) + (wave.boxTopPrice - wave.price4) + wave.price3
    wave.boxTopPrice4 := 4 * (wave.price4 - wave.price3) + (wave.boxTopPrice - wave.price4) + wave.price3
    wave.boxTopPrice5 := 5 * (wave.price4 - wave.price3) + (wave.boxTopPrice - wave.price4) + wave.price3
    float halfADPriceN = 0.5 * (math.max(wave.price1, wave.price2, wave.price3, wave.priceD) - math.min(wave.price1, wave.price2, wave.price3, wave.priceD))                                    // ABCD median (relative) for N
    float halfADPriceS = 0.5 * (math.max(wave.price3, wave.priceD) - math.min(wave.price3, wave.priceD))                                                                                        // CD median (relative) for S
    wave.midADPrice := wave.sWave ? (wave.baNegative ? wave.price3 - halfADPriceS : wave.price3 + halfADPriceS) : (wave.baNegative ? wave.price1 - halfADPriceN : wave.price1 + halfADPriceN)   // ABCD/CD mid point (absolute) for N or for S
    wave.boxPriceEBot := wave.midADPrice
    float deltaEN = wave.boxTopPrice - wave.price4
    if wave.sWave
        wave.boxPriceETop := wave.boxPriceEBot + closestLevelS(wave.baNegative, wave.priceD, wave.boxSmPrice, wave.boxSPrice, wave.boxYPrice)
    else
        wave.boxPriceETop := wave.boxPriceEBot + closestLevelN(wave.baNegative, wave.priceD, (wave.pWave ? wave.boxPPrice : wave.boxNtPrice), wave.price4, wave.boxTopPrice, wave.boxTopPrice2 - deltaEN, wave.boxTopPrice2, wave.boxTopPrice3 - deltaEN, wave.boxTopPrice3, wave.boxTopPrice4 - deltaEN, wave.boxTopPrice4)
    wave.boxTimeE0 := (wave.timeD - wave.time3) + wave.timeD
    wave.boxTimeE1 := (wave.timeD - wave.time1) + wave.timeD
    wave.boxPriceEAnchor := wave.baNegative ? wave.priceD + math.min(wave.boxPriceEBot - wave.priceD, wave.boxPriceETop - wave.priceD) : wave.priceD + math.max(wave.boxPriceEBot - wave.priceD, wave.boxPriceETop - wave.priceD)
    wave.boxPriceELabels := wave.baNegative ? wave.priceD + math.max(wave.boxPriceEBot - wave.priceD, wave.boxPriceETop - wave.priceD) : wave.priceD + math.min(wave.boxPriceEBot - wave.priceD, wave.boxPriceETop - wave.priceD)

    // arrows extended to last deadline (TIME #3 aka boxTime1 in code)
    int exTime4 = wave.boxTime1 - wave.time3
    int time34 = wave.time4 - wave.time3
    wave.price4Ex := wave.price3 + ((wave.price4 - wave.price3) / time34) * exTime4                 // price4 aka N
    wave.boxEPriceEx := wave.price3 + ((wave.boxEPrice - wave.price3) / time34) * exTime4
    wave.boxYPriceEx := wave.price3 + ((wave.boxYPrice - wave.price3) / time34) * exTime4
    wave.boxVPriceEx := wave.price3 + ((wave.boxVPrice - wave.price3) / time34) * exTime4
    wave.boxSPriceEx := wave.price3 + ((wave.boxSPrice - wave.price3) / time34) * exTime4
    wave.boxNtPriceEx := wave.price3 + ((wave.boxNtPrice - wave.price3) / time34) * exTime4
    wave.boxPPriceEx := wave.price3 + ((wave.boxPPrice - wave.price3) / time34) * exTime4
    wave.boxSmPriceEx := wave.price3 + ((wave.boxSmPrice - wave.price3) / time34) * exTime4

    drawIndicator(wave)

if barstate.islast
    
    if kisu or ksob or ksoc
        table.cell(tabKisu, 0, 0, "Kihon Suchi 9, 17, 26, 33, 42, 51, 65, 76,,,", 17, 3, text_color = color.yellow, text_size = size.small, bgcolor = color.rgb(61, 61, 61))

// Ichimoku stuff
plot(ichi ? conversionLine : na, color=#4385ff, title="Tekan Conversion Line", linewidth=2)                                        // TENKAN SEN
plot(ichi ? baseLine : na, color=#f83737, title="Kijun Base Line", linewidth=2)                                                    // KIJUN SEN
plot(ichi ? close : na, offset = -displacement + 1, color=#43A047, title="Lagging Chikou Span")
p1 = plot(ichi ? leadLine1 : na, offset = displacement - 1, color=#A5D6A7, title="Leading Senkou Span A")
p2 = plot(ichi ? leadLine2 : na, offset = displacement - 1, color=#EF9A9A, title="Leading Senkou Span B")
//plot(ichi ? (leadLine1 > leadLine2 ? leadLine1 : leadLine2) : na, offset = displacement - 1, title = "Kumo Cloud Upper Line", color = #7eff83, display = display.none)
//plot(ichi ? (leadLine1 < leadLine2 ? leadLine1 : leadLine2) : na, offset = displacement - 1, title = "Kumo Cloud Lower Line", color = #ff6464, display = display.none)
fill(p1, p2, color = leadLine1 > leadLine2 ? color.rgb(67, 160, 71, 90) : color.rgb(244, 67, 54, 90))
plot((ichi and crss) ? (ta.crossover(conversionLine,baseLine) ? baseLine : na) : na,'Crossover',#2157f3,3,plot.style_circles)
plot((ichi and crss) ? (ta.crossunder(conversionLine,baseLine) ? baseLine : na) : na,'Crossunder',#ff5d00,3,plot.style_circles)

// Display of the Tenkan Crossover Gaps
if crss and barstate.islastconfirmedhistory

    lastCrossover = array.get(crossoverBars, array.size(crossoverBars) - 1)
    lastCrossoverDist = array.get(crossoverDist, array.size(crossoverBars) - 1)

    // Kihon Suchi Cycles
    if kisu and ksob == false and ksoc == false
        int[] cycles = array.from(0,9,17,26,33,42,51,65,76,83,97,101,151,226)
        for i = array.size(cycles) - 1 to 0
            if array.get(cycles, i) <= ksmx 
                cycle = array.get(cycles, i) + lastCrossBar + ksof
                if i > 0
                    line.new(cycle, math.min(y1Input, y2Input, y3Input), cycle, math.max(y1Input, y2Input, y3Input), xloc.bar_index, extend.both, color.yellow, line.style_dotted, 1)
                label.new(cycle, y2Input, str.format(n2pad, array.get(cycles, i)), xloc.bar_index, yloc.price, color.rgb(27, 32, 36, 100), label.style_label_left, color.yellow )
        line.new(lastCrossover + lastCrossoverDist, math.min(y1Input, y2Input, y3Input), lastCrossover + lastCrossoverDist, math.max(y1Input, y2Input, y3Input), xloc.bar_index, extend.both, color.rgb(255, 217, 0), line.style_dashed, 1)
        label.new(lastCrossover + lastCrossoverDist, y2Input, str.format(n2pad, lastCrossoverDist), xloc.bar_index, yloc.price, color.rgb(128, 128, 128, 80), label.style_label_up, color.yellow )

    // Print the list of crossover bars and distances
    for i = array.size(crossoverBars) - 1 to 0
        int v = array.get(crossoverBars, i)
        int d = array.get(crossoverDist, i)
        labelCount := labelCount + 1
        if labelCount <= maxl
            if i == array.size(crossoverBars) - 1
                label.new(v, na, "⬅ " + str.format(n3pad, d) + "\n→" + str.format(n3pad, 1 + bar_index - lastCrossover), xloc.bar_index, yloc.abovebar, color.rgb(255, 0, 0), label.style_arrowdown, color.rgb(117, 188, 255), size.normal)
            else    
                label.new(v, na, "⬅ " + str.format(n3pad, d), xloc.bar_index, yloc.abovebar, color.rgb(255, 0, 0), label.style_arrowdown, color.rgb(117, 188, 255), size.normal)

// EMA
out = ta.ema(src, len)
plot(dema ? out : na, title="EMA Line", color=color.rgb(240, 243, 33), offset=offset, linewidth = 1)
