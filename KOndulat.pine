//@version=5
indicator("Kir Ondulatoire", shorttitle="KOndulat", overlay=true, max_labels_count = 150)

    // version 0.9.4

    // Copyright (C) 2024  Kir (https://github.com/Kirken2004/tv-kir-ondulat)

    // This program is free software; you can redistribute it and/or modify
    // it under the terms of the GNU General Public License as published by
    // the Free Software Foundation; either version 2 of the License, or
    // (at your option) any later version.

    // This program is distributed in the hope that it will be useful,
    // but WITHOUT ANY WARRANTY; without even the implied warranty of
    // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    // GNU Lesser General Public License for more details.

    // You should have received a copy of the GNU Lesser General Public License along
    // with this program; if not, write to the Free Software Foundation, Inc.,
    // 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

int       TIME_DEFAULT  = 0
float     PRICE_DEFAULT = 0.0

x1Input = input.time(TIME_DEFAULT,   "Point A", inline = "1", confirm = true)
y1Input = input.price(PRICE_DEFAULT, "",        inline = "1", tooltip = "Pick point A", confirm = true)
x2Input = input.time(TIME_DEFAULT,   "Point B", inline = "2", confirm = true)
y2Input = input.price(PRICE_DEFAULT, "",        inline = "2", tooltip = "Pick point B", confirm = true)
x3Input = input.time(TIME_DEFAULT,   "Point C", inline = "3", confirm = true)
y3Input = input.price(PRICE_DEFAULT, "",        inline = "3", tooltip = "Pick point C", confirm = true)
x4Input = input.time(TIME_DEFAULT,   "Point D", inline = "4", confirm = true)
y4Input = input.price(PRICE_DEFAULT, "",        inline = "4", tooltip = "Pick point D (place before C to ignore)", confirm = true)

pret = input.float(defval=50.0, title="% Retracement for a P-Wave", inline="option1", group="Wave options", tooltip="By default, a P wave is forming if the move BC retraced more than 50% of AB. N waves are more certain between 33% and 50%. Alter this if you think the situation is blurry.")
mult = input.bool(defval=false, title="Multiples of E/N waves", inline="option2", group="Wave options", tooltip="Won't work in case of an S-Wave")
ebox = input.bool(defval=true, title="E-Box", inline="option3", group="Wave options", tooltip="Need the point D to be placed after time C [STILL BUGGED AT THE MOMENT].")
ecol = input.color(defval=color.aqua, title=" ", inline="option3", group="Wave options")
tend = input.bool(defval=false, title="Straight Linear Projection", inline="option4", group="Wave options", tooltip="SLP: As long as the TARGET TIME is not reached, a purple arrow will point to the target. A purple label will give the estimated target price. It's a silly feature.")
labp = input.bool(defval=false, title="Price in labels", inline="option5", group="Wave options")
tren = input.bool(defval=false, title="Wave Trend Lines", inline="option6", group="Wave options", tooltip = "Only visibles if D label is also visible. Help to visually confirm if ABCD is an N/Y/P wave.")
tcol = input.color(defval=color.green, title=" ", inline="option6", group="Wave options")
twid = input.int(defval=2, title="Width", inline="option6", group="Wave options")

ichi = input.bool(defval=false, title="Ichimoku Kinko Hyo", inline="option1", group="Ichimoku options")
crss = input.bool(defval=false, title="Tenkan Crossover/under markers.", inline="option2", group="Ichimoku options")
maxl = input.int(10, minval=1, title=" up to", inline="option2", group="Ichimoku options", tooltip = "An indicator is limited in the allowed amount of labels to draw. Keep this value low enough to prevent having lost labels.")

ksof = input.int(defval=0, title="Offseted in bars", inline="option1", group="Kihon Suchi options")
ksmx = input.int(defval=42, title="Max period", inline="option1", group="Kihon Suchi options", tooltip = "Won't draw Ichimoku times after this elapsed period")
kisu = input.bool(defval=false, title="from last Crossover", inline="option2", group="Kihon Suchi options", tooltip = "Need Tenkan crossovers to be displayed to work.")
ksob = input.bool(defval=false, title="from B", inline="option2", group="Kihon Suchi options", tooltip = "Won't work if previous option is checked.")

ac26 = input.bool(defval=false, title="26 periods after A/C", inline="option1", group="Miscellaneous options", tooltip = "The Kumo cloud between those two deadlines gives an active area to keep an eye on. Up to you to draw a bounding box there.")
dema = input.bool(defval=false, title="EMA", inline="option2", group="Miscellaneous options")
fibo = input.bool(defval=false, title="Fibonacci Axis", inline="option3", group="Miscellaneous options")
cton = input.bool(defval=false, title="C to N", inline="option3", group="Miscellaneous options", tooltip="C to N: Gives you the expected pluvalue from C to N, then the realised ratio.\nN/AB gives you the current position on the fibo axis. To N when in continuation, to AB when retracing C.")

int realtimeTime = 1
float realtimePrice = 1.0
int labelCount = 0

var tab = table.new(position.bottom_center, 1, 1)

type Wave
    int   time1
    int   time2
    int   time3
    int   time4
    int   timeD
    float price1
    float price2
    float price3
    float price4
    float priceD
    color lineColor
    color arrowColorNS
    color arrowColorEY
    color arrowColorVSm
    color arrowColorNtP
    float priceDelta1
    float priceDelta2
    int   timeDelta1
    int   timeDelta2
    int   boxTime0
    int   boxTime1
    int   boxTimeE0
    int   boxTimeE1
    float boxTopPrice
    float boxTopPrice2
    float boxTopPrice3
    float boxTopPrice4
    float boxTopPrice5
    float boxEPrice
    float boxVPrice
    float boxNtPrice
    float boxPPrice
    float boxYPrice
    float boxSPrice
    float boxSmPrice
    float boxPriceETop
    float boxPriceEBot
    float boxPriceEAnchor
    float boxPriceELabels
    float currentPrice
    float midADPrice
    int   currentTime
    int   barWidthInPixels
    bool  baNegative
    bool  nWave
    bool  pWave
    bool  sWave
    float retracement

// Fibonacci stuff
fiboBarWidth = input.int(2, minval=-1000, maxval=1000, title="Fibo width in bars", group="Fibonacci Axis", tooltip = "Due to the lack of scale/zoom detection, the width of the graduations is expressed in a multiplier of bar width")
fiboBarOffset = input.int(0, minval=-1000, maxval=1000, title="Offset to the right of the target window", group="Fibonacci Axis", tooltip="Due to the lack of scale/zoom detection, the axis is offseted from B Point by an amount of bar width")

// Ichimoku stuff
donchian(len) => math.avg(ta.lowest(len), ta.highest(len))
conversionPeriods = input.int(9, minval=1, title="Conversion Line Length", group="Ichimoku")
basePeriods = input.int(26, minval=1, title="Base Line Length", group="Ichimoku")
laggingSpan2Periods = input.int(52, minval=1, title="Leading Span B Length", group="Ichimoku")
displacement = input.int(26, minval=1, title="Lagging Span", group="Ichimoku")
conversionLine = donchian(conversionPeriods)
baseLine = donchian(basePeriods)
leadLine1 = math.avg(conversionLine, baseLine)
leadLine2 = donchian(laggingSpan2Periods)

// Tenkan crossovers with Kijun
crossoverUp = ta.crossover(conversionLine, baseLine)
crossoverDown = ta.crossunder(conversionLine, baseLine)

// Initialize variables for keeping track of crossover bars and distance last one
var int lastCrossBar = na
var int crossDistance = na
var int[] crossoverBars = array.new_int(0)
var int[] crossoverDist = array.new_int(0)

// Calculate distance in bars between crossovers
if crossoverUp or crossoverDown
    if not na(lastCrossBar)
        crossDistance := bar_index - lastCrossBar
        array.push(crossoverBars, bar_index)
        array.push(crossoverDist, crossDistance)
    lastCrossBar := bar_index

// EMA
len = input.int(200, minval=1, title="Length", group="Exponential Moving Average")
src = input(close, title="Source", group="Exponential Moving Average")
offset = input.int(title="Offset", defval=0, minval=-500, maxval=500, display = display.data_window, group="Exponential Moving Average")
typeMA = input.string(title = "Method", defval = "SMA", options=["SMA", "EMA", "SMMA (RMA)", "WMA", "VWMA"], group="Exponential Moving Average", display = display.data_window)
smoothingLength = input.int(title = "Length", defval = 5, minval = 1, maxval = 100, group="Exponential Moving Average", display = display.data_window)

int nb_seconds = timeframe.in_seconds(timeframe.period)
int candleTime = nb_seconds * 1000

var labelRetracementBC = label.new(x=na, y=na, text="Retracement BC: na", color=color.rgb(70, 3, 81, 45), textcolor=color.rgb(255, 255, 255), style=label.style_label_up, xloc=xloc.bar_time)

var labelTargetTime = label.new(x=na, y=na, text="Test", color=color.rgb(0, 137, 123, 45), textcolor=color.rgb(255, 221, 117), style=label.style_label_up, xloc=xloc.bar_time, size=size.small)
var labelBeforeTargetTime = label.new(x=na, y=na, text="Test", color=color.rgb(0, 137, 123, 48), textcolor=color.rgb(255, 255, 255, 34), style=label.style_label_down, xloc=xloc.bar_time, size=size.small)
var labelAfterTargetTime = label.new(x=na, y=na, text="Test", color=color.rgb(0, 137, 123, 48), textcolor=color.rgb(255, 255, 255, 34), style=label.style_label_down, xloc=xloc.bar_time, size=size.small)

var labelTargetPriceE = label.new(x=na, y=na, text="E= na", color=color.rgb(120, 123, 134, 90), textcolor=color.blue, style=label.style_label_left, xloc=xloc.bar_time)
var labelTargetPriceN = label.new(x=na, y=na, text="N= na", color=color.rgb(120, 123, 134, 90), textcolor=color.orange, style=label.style_label_left, xloc=xloc.bar_time)
var labelTargetPriceV = label.new(x=na, y=na, text="V= na", color=color.rgb(120, 123, 134, 90), textcolor=color.rgb(255, 82, 102), style=label.style_label_left, xloc=xloc.bar_time)
var labelTargetPriceNt = label.new(x=na, y=na, text="NT= na", color=color.rgb(120, 123, 134, 90), textcolor=color.green, style=label.style_label_left, xloc=xloc.bar_time)
var labelTargetPriceP = label.new(x=na, y=na, text="P= na", color=color.rgb(120, 123, 134, 90), textcolor=color.lime, style=label.style_label_left, xloc=xloc.bar_time)

var labelTargetPriceY = label.new(x=na, y=na, text="Y= na", color=color.rgb(120, 123, 134, 90), textcolor=color.blue, style=label.style_label_left, xloc=xloc.bar_time)
var labelTargetPriceS = label.new(x=na, y=na, text="S= na", color=color.rgb(120, 123, 134, 90), textcolor=color.orange, style=label.style_label_left, xloc=xloc.bar_time)
var labelTargetPriceSm = label.new(x=na, y=na, text="Sm= na", color=color.rgb(120, 123, 134, 90), textcolor=color.rgb(255, 82, 102), style=label.style_label_left, xloc=xloc.bar_time)

var labelTargetPrice2E = label.new(x=na, y=na, text="2E: na", color=color.rgb(120, 123, 134, 90), textcolor=color.blue, style=label.style_label_left, xloc=xloc.bar_time)
var labelTargetPrice2N = label.new(x=na, y=na, text="2N: na", color=color.rgb(120, 123, 134, 90), textcolor=color.orange, style=label.style_label_left, xloc=xloc.bar_time)
var labelTargetPrice3E = label.new(x=na, y=na, text="3E: na", color=color.rgb(120, 123, 134, 90), textcolor=color.blue, style=label.style_label_left, xloc=xloc.bar_time)
var labelTargetPrice3N = label.new(x=na, y=na, text="3N: na", color=color.rgb(120, 123, 134, 90), textcolor=color.orange, style=label.style_label_left, xloc=xloc.bar_time)
var labelTargetPrice4E = label.new(x=na, y=na, text="4E: na", color=color.rgb(120, 123, 134, 90), textcolor=color.blue, style=label.style_label_left, xloc=xloc.bar_time)
var labelTargetPrice4N = label.new(x=na, y=na, text="4N: na", color=color.rgb(120, 123, 134, 90), textcolor=color.orange, style=label.style_label_left, xloc=xloc.bar_time)
var labelTargetPrice5E = label.new(x=na, y=na, text="4E: na", color=color.rgb(120, 123, 134, 90), textcolor=color.blue, style=label.style_label_left, xloc=xloc.bar_time)
var labelTargetPrice5N = label.new(x=na, y=na, text="4N: na", color=color.rgb(120, 123, 134, 90), textcolor=color.orange, style=label.style_label_left, xloc=xloc.bar_time)

var labelTargetPriceETop = label.new(x=na, y=na, text="Emax", color=color.rgb(120, 123, 134, 90), textcolor=ecol, style=label.style_label_left, xloc=xloc.bar_time)
var labelTargetPriceEBot = label.new(x=na, y=na, text="Emin", color=color.rgb(120, 123, 134, 90), textcolor=ecol, style=label.style_label_left, xloc=xloc.bar_time)
var labelBeforeTargetETime = label.new(x=na, y=na, text="Test", color=color.rgb(0, 137, 123, 48), textcolor=color.rgb(255, 255, 255, 34), style=label.style_label_up, xloc=xloc.bar_time, size=size.small)
var labelAfterTargetETime = label.new(x=na, y=na, text="Test", color=color.rgb(0, 137, 123, 48), textcolor=color.rgb(255, 255, 255, 34), style=label.style_label_up, xloc=xloc.bar_time, size=size.small)

var labelFiboTextColor = color.teal
var labelFiboTextColorNeg = color.rgb(0, 104, 93)
var labelFiboTextColorNegCrash = color.red
var labelFiboTextColorGoal = color.rgb(165, 209, 204)
var labelFiboTextColorGold = color.rgb(255, 224, 71)
var labelFibo0 = label.new(x=na, y=na, text="    0 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColor, style=label.style_label_left, xloc=xloc.bar_time)
var labelFibo23 = label.new(x=na, y=na, text="23.6 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColor, style=label.style_label_left, xloc=xloc.bar_time)
var labelFibo38 = label.new(x=na, y=na, text="38.2 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColor, style=label.style_label_left, xloc=xloc.bar_time)
var labelFibo50 = label.new(x=na, y=na, text="50.0 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColor, style=label.style_label_left, xloc=xloc.bar_time)
var labelFibo61 = label.new(x=na, y=na, text="61.8 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColor, style=label.style_label_left, xloc=xloc.bar_time)
var labelFibo78 = label.new(x=na, y=na, text="78.8 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColor, style=label.style_label_left, xloc=xloc.bar_time)
var labelFibo100 = label.new(x=na, y=na, text=" 100 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColorGoal, style=label.style_label_left, xloc=xloc.bar_time)
var labelFibo123 = label.new(x=na, y=na, text=" 123 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColorGoal, style=label.style_label_left, xloc=xloc.bar_time)
var labelFibo138 = label.new(x=na, y=na, text=" 138 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColorGoal, style=label.style_label_left, xloc=xloc.bar_time)
var labelFibo161 = label.new(x=na, y=na, text=" 161 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColorGold, style=label.style_label_left, xloc=xloc.bar_time)
var labelFibo178 = label.new(x=na, y=na, text=" 178 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColorGold, style=label.style_label_left, xloc=xloc.bar_time)
var labelFibo200 = label.new(x=na, y=na, text=" 200 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColorGold, style=label.style_label_left, xloc=xloc.bar_time)

var labelFiboN0 = label.new(x=na, y=na, text="-0 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColorNeg, style=label.style_label_right, xloc=xloc.bar_time)
var labelFiboN23 = label.new(x=na, y=na, text="-23.6 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColorNeg, style=label.style_label_right, xloc=xloc.bar_time)
var labelFiboN38 = label.new(x=na, y=na, text="-38.2 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColorNeg, style=label.style_label_right, xloc=xloc.bar_time)
var labelFiboN50 = label.new(x=na, y=na, text="-50.0 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColorNeg, style=label.style_label_right, xloc=xloc.bar_time)
var labelFiboN61 = label.new(x=na, y=na, text="-61.8 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColorNeg, style=label.style_label_right, xloc=xloc.bar_time)
var labelFiboN78 = label.new(x=na, y=na, text="-78.8 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColorNeg, style=label.style_label_right, xloc=xloc.bar_time)
var labelFiboN100 = label.new(x=na, y=na, text=" -100 %", color=color.rgb(120, 123, 134, 100), textcolor = labelFiboTextColorNegCrash, style=label.style_label_right, xloc=xloc.bar_time)

// Main Drawing function using Wave theory about N Waves with Undulatory by Hosoda
drawIndicator(Wave t) =>

    // Wave lines, Box and Arrows
    line.new(t.time1, t.price1, t.time2, t.price2, xloc = xloc.bar_time, color = t.lineColor, width=3, style=line.style_dotted)                                                                                                          // dotted impulse
    line.new(t.time2, t.price2, t.time3, t.price3, xloc = xloc.bar_time, color = t.lineColor, width=3, style=line.style_dotted)                                                                                                          // dotted correction
    line.new(t.time3, t.price3, t.timeD, t.priceD, xloc = xloc.bar_time, color = t.lineColor, width=3, style=line.style_dotted)                                                                                                          // dotted D wave

    if t.nWave or t.pWave
        // arrows
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.price3 + t.priceDelta1, xloc = xloc.bar_time, color = t.arrowColorNS, width=1, style=line.style_arrow_right)                                                               // orange arrow N (prime)        C+(B-A)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice, xloc = xloc.bar_time, color = t.arrowColorEY, width=1, style=line.style_arrow_right)                                                                          // blue arrow E (highest/lowest) B+(B-A)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxVPrice, xloc = xloc.bar_time, color = t.arrowColorVSm, width=1, style=line.style_arrow_right)                                                                           // red arrow V      B+(B-C)
        if t.pWave == false
            line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxNtPrice, xloc = xloc.bar_time, color = t.arrowColorNtP, width=1, style=line.style_arrow_right)                                                                      // green arrow Nt   C+(C-A)
        if t.pWave
            line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxPPrice, xloc = xloc.bar_time, color = t.arrowColorNtP, width=1, style=line.style_arrow_right)                                                                       // green arrow P
        // levels
        line.new(t.boxTime0, t.price4, t.boxTime1, t.price4, xloc = xloc.bar_time, color = t.arrowColorNS, width=1, style=line.style_dotted)                                                                                             // level N
        line.new(t.boxTime0, t.boxTopPrice, t.boxTime1, t.boxTopPrice, xloc = xloc.bar_time, color = t.arrowColorEY, width=1, style=line.style_dotted)                                                                                   // level E
        line.new(t.boxTime0, t.boxVPrice, t.boxTime1, t.boxVPrice, xloc = xloc.bar_time, color = t.arrowColorVSm, width=1, style=line.style_dotted)                                                                                      // level V
        if t.pWave == false
            line.new(t.boxTime0, t.boxNtPrice, t.boxTime1, t.boxNtPrice, xloc = xloc.bar_time, color = t.arrowColorNtP, width=1, style=line.style_dotted)                                                                                // level Nt
        if t.pWave
            line.new(t.boxTime0, t.boxPPrice, t.boxTime1, t.boxPPrice, xloc = xloc.bar_time, color = t.arrowColorNtP, width=1, style=line.style_dotted)                                                                                  // level P (prime)

    if t.sWave
        // arrows
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxSPrice, xloc = xloc.bar_time, color = t.arrowColorNS, width=1, style=line.style_arrow_right)                                                                            // orange arrow S (prime)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxYPrice, xloc = xloc.bar_time, color = t.arrowColorEY, width=1, style=line.style_arrow_right)                                                                            // blue arrow Y (highest/lowest)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxSmPrice, xloc = xloc.bar_time, color = t.arrowColorVSm, width=1, style=line.style_arrow_right)                                                                          // red arrow Sm (median)
        // levels
        line.new(t.boxTime0, t.boxSPrice, t.boxTime1, t.boxSPrice, xloc = xloc.bar_time, color = t.arrowColorNS, width=1, style=line.style_dotted)                                                                                       // level S
        line.new(t.boxTime0, t.boxYPrice, t.boxTime1, t.boxYPrice, xloc = xloc.bar_time, color = t.arrowColorEY, width=1, style=line.style_dotted)                                                                                       // level Y
        line.new(t.boxTime0, t.boxSmPrice, t.boxTime1, t.boxSmPrice, xloc = xloc.bar_time, color = t.arrowColorVSm, width=1, style=line.style_dotted)                                                                                    // level Sm

    if ac26
        int candleTime25x = 25 * candleTime
        int time1plus26 = t.time1 + candleTime25x
        int time3plus26 = t.time3 + candleTime25x
        float highest = math.max(t.price1, t.price2, t.price3, t.priceD, t.boxTopPrice)
        float lowest = math.min(t.price1, t.price2, t.price3, t.priceD, t.boxTopPrice)
        line.new(time1plus26, highest, time1plus26, lowest, xloc = xloc.bar_time, color = color.orange, width=1, style=line.style_dotted)                                                                                             // time A + 26 periods
        line.new(time3plus26, highest, time3plus26, lowest, xloc = xloc.bar_time, color = color.orange, width=1, style=line.style_dotted)                                                                                             // time C + 26 periods

    if mult and t.sWave == false
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice2, xloc = xloc.bar_time, color = t.arrowColorEY, width=1, style=line.style_arrow_right)                                                                         // blue arrow 2E (highest)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice2 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = t.arrowColorNS, width=1, style=line.style_arrow_right)                                            // orange arrow 2N (prime)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice3, xloc = xloc.bar_time, color = t.arrowColorEY, width=1, style=line.style_arrow_right)                                                                         // blue arrow 3E (highest)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice3 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = t.arrowColorNS, width=1, style=line.style_arrow_right)                                            // orange arrow 3N (prime)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice4, xloc = xloc.bar_time, color = t.arrowColorEY, width=1, style=line.style_arrow_right)                                                                         // blue arrow 4E (highest)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice4 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = t.arrowColorNS, width=1, style=line.style_arrow_right)                                            // orange arrow 4N (prime)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice5, xloc = xloc.bar_time, color = t.arrowColorEY, width=1, style=line.style_arrow_right)                                                                         // blue arrow 5E (highest)
        line.new(t.time3, t.price3, t.time3 + t.timeDelta1, t.boxTopPrice5 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = t.arrowColorNS, width=1, style=line.style_arrow_right)                                            // orange arrow 5N (prime)
        line.new(t.boxTime0, t.boxTopPrice2 - (t.boxTopPrice - t.price4), t.boxTime1, t.boxTopPrice2 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = t.arrowColorNS, width=1, style=line.style_dotted)                       // level 2N
        line.new(t.boxTime0, t.boxTopPrice2, t.boxTime1, t.boxTopPrice2, xloc = xloc.bar_time, color = t.arrowColorEY, width=1, style=line.style_dotted)                                                                                 // level 2E
        line.new(t.boxTime0, t.boxTopPrice3 - (t.boxTopPrice - t.price4), t.boxTime1, t.boxTopPrice3 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = t.arrowColorNS, width=1, style=line.style_dotted)                       // level 3N
        line.new(t.boxTime0, t.boxTopPrice3, t.boxTime1, t.boxTopPrice3, xloc = xloc.bar_time, color = t.arrowColorEY, width=1, style=line.style_dotted)                                                                                 // level 3E
        line.new(t.boxTime0, t.boxTopPrice4 - (t.boxTopPrice - t.price4), t.boxTime1, t.boxTopPrice4 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = t.arrowColorNS, width=1, style=line.style_dotted)                       // level 4N
        line.new(t.boxTime0, t.boxTopPrice4, t.boxTime1, t.boxTopPrice4, xloc = xloc.bar_time, color = t.arrowColorEY, width=1, style=line.style_dotted)                                                                                 // level 4E
        line.new(t.boxTime0, t.boxTopPrice5 - (t.boxTopPrice - t.price4), t.boxTime1, t.boxTopPrice5 - (t.boxTopPrice - t.price4), xloc = xloc.bar_time, color = t.arrowColorNS, width=1, style=line.style_dotted)                       // level 5N
        line.new(t.boxTime0, t.boxTopPrice5, t.boxTime1, t.boxTopPrice5, xloc = xloc.bar_time, color = t.arrowColorEY, width=1, style=line.style_dotted)                                                                                 // level 5E

    line.new(t.time3 + t.timeDelta2, t.price3, t.time3 + t.timeDelta2, t.boxTopPrice, xloc = xloc.bar_time, color = t.arrowColorVSm, width=1, style=line.style_dashed)                                                                   // dashed at double correction time

    box.new(t.boxTime0, t.boxTopPrice, t.boxTime1, t.price3, border_color = color.teal, border_width = 1, border_style = line.style_solid, bgcolor = na, xloc=xloc.bar_time)                                                           // target box deadline
    line.new(t.time3 + t.timeDelta1, t.boxTopPrice, t.time3 + t.timeDelta1, t.price3, xloc=xloc.bar_time, style = line.style_dashed, width = 1, color=color.teal)                                                                      // target dashed dateline

    // toggle the direction of things considering the relation between time A and time B
    var styleABC = label.style_label_up
    var styleABC2 = label.style_label_down
    var styleRetrac = label.style_label_up
    if t.price2 < t.price1
        styleABC := label.style_label_down
        styleABC2 := label.style_label_up
        styleRetrac := label.style_label_down

    // Point Colors
    pointTextColor = color.black
    pointFillColor = color.rgb(105, 155, 255)

    // Wave labels
    var textA = "A" + (labp ? "\n" + str.format("{0, number, #.##}", t.price1) : "")
    var textB = "B\n" + str.format("{0, number, ###}", 1 + ((t.time2 - t.time1) / nb_seconds / 1000)) + (labp ? "\n" + str.format("{0, number, #.##}", t.price2) : "")
    var textC = "C\n" + str.format("{0, number, ###}", 1 + ((t.time3 - t.time1 + 1.001) / nb_seconds / 1000)) + (labp ? "\n" + str.format("{0, number, #.##}", t.price3) : "")
    label.new(t.time1, t.price1, textA, xloc.bar_time, yloc.price, pointFillColor, styleABC, pointTextColor, size.small, text.align_center)
    label.new(t.time2, t.price2, textB, xloc.bar_time, yloc.price, pointFillColor, styleABC2, pointTextColor, size.small, text.align_center)
    label.new(t.time3, t.price3, textC, xloc.bar_time, yloc.price, pointFillColor, styleABC, pointTextColor, size.small, text.align_center)

    // Compute tenth (deciles) of the box duration
    priceDeci = (t.price4 - t.price3) / 10
    timeDeci = (t.boxTime1 - t.boxTime0) / 10
    int labelTextWidth = str.length(labelTargetPriceNt.get_text()) * 6 / 10
    //log.info(str.format("{0, number, ###.###}", labelTextWidth))

    // Retracement of C over BA
    labelRetracementBC.set_style(styleRetrac)
    labelRetracementBC.set_x(math.floor(t.time2 + (t.time3 - t.time2)))
    labelRetracementBC.set_y(t.price2 - (1.8 * math.abs(t.price2 - t.price3)))
    if t.baNegative
        labelRetracementBC.set_y(t.price2 + (1.8 * math.abs(t.price3 - t.price2)))
    labelRetracementBC.set_yloc(yloc.price)
    labelRetracementBC.set_text("retracement BC: " + str.format("{0, number, #.##}", t.retracement) + "%")

    // Box date labels
    if t.baNegative
        labelTargetTime.set_style(label.style_label_down)
        labelBeforeTargetTime.set_style(label.style_label_up), labelAfterTargetTime.set_style(label.style_label_up)

    labelTargetTime.set_x(t.time4)
    labelTargetTime.set_y(t.price3)
    labelTargetTime.set_yloc(yloc.price)
    labelTargetTime.set_text(str.format_time(t.time4, 'dd-MMM-yyyy\nHH:mm:ss', "UTC+2"))

    labelBeforeTargetTime.set_x(t.boxTime0)
    labelBeforeTargetTime.set_y(t.boxTopPrice)
    labelBeforeTargetTime.set_yloc(yloc.price)
    labelBeforeTargetTime.set_text(str.format_time(t.boxTime0, 'dd-MMM-yyyy\nHH:mm:ss', "UTC+2"))

    labelAfterTargetTime.set_x(t.boxTime1)
    labelAfterTargetTime.set_y(t.boxTopPrice)
    labelAfterTargetTime.set_yloc(yloc.price)
    labelAfterTargetTime.set_text(str.format_time(t.boxTime1, 'dd-MMM-yyyy\nHH:mm:ss', "UTC+2"))

    // Arrow Labels
    if t.sWave == false
        labelTargetPriceE.set_x(t.boxTime1)
        labelTargetPriceE.set_y(t.boxTopPrice)
        labelTargetPriceE.set_yloc(yloc.price)
        labelTargetPriceE.set_text("E=" + str.format("{0, number, #.####}", t.boxTopPrice))

        labelTargetPriceN.set_x(t.boxTime1)
        labelTargetPriceN.set_y(t.price4)
        labelTargetPriceN.set_yloc(yloc.price)
        labelTargetPriceN.set_text("N=" + str.format("{0, number, #.####}", t.price4))

        labelTargetPriceV.set_x(t.boxTime1)
        labelTargetPriceV.set_y(t.boxVPrice)
        labelTargetPriceV.set_yloc(yloc.price)
        labelTargetPriceV.set_text("V=" + str.format("{0, number, #.####}", t.boxVPrice))

    if t.pWave == false and t.sWave == false
        labelTargetPriceNt.set_x(t.boxTime1)
        labelTargetPriceNt.set_y(t.boxNtPrice)
        labelTargetPriceNt.set_yloc(yloc.price)
        labelTargetPriceNt.set_text("NT=" + str.format("{0, number, #.####}", t.boxNtPrice))

    if t.pWave
        labelTargetPriceP.set_x(t.boxTime1)
        labelTargetPriceP.set_y(t.boxPPrice)
        labelTargetPriceP.set_yloc(yloc.price)
        labelTargetPriceP.set_text("P=" + str.format("{0, number, #.####}", t.boxPPrice))

    if t.sWave
        labelTargetPriceY.set_x(t.boxTime1)
        labelTargetPriceY.set_y(t.boxYPrice)
        labelTargetPriceY.set_yloc(yloc.price)
        labelTargetPriceY.set_text("Y=" + str.format("{0, number, #.####}", t.boxYPrice))

        labelTargetPriceS.set_x(t.boxTime1)
        labelTargetPriceS.set_y(t.boxSPrice)
        labelTargetPriceS.set_yloc(yloc.price)
        labelTargetPriceS.set_text("S=" + str.format("{0, number, #.####}", t.boxSPrice))

        labelTargetPriceSm.set_x(t.boxTime1)
        labelTargetPriceSm.set_y(t.boxSmPrice)
        labelTargetPriceSm.set_yloc(yloc.price)
        labelTargetPriceSm.set_text("Sm=" + str.format("{0, number, #.####}", t.boxSmPrice))
        
    if mult and t.sWave == false
        labelTargetPrice2E.set_x(t.boxTime1)
        labelTargetPrice2E.set_y(t.boxTopPrice2)
        labelTargetPrice2E.set_yloc(yloc.price)
        labelTargetPrice2E.set_text("2E=" + str.format("{0, number, #.####}", t.boxTopPrice2))

        labelTargetPrice2N.set_x(t.boxTime1)
        labelTargetPrice2N.set_y(t.boxTopPrice2 - (t.boxTopPrice - t.price4))
        labelTargetPrice2N.set_yloc(yloc.price)
        labelTargetPrice2N.set_text("2N=" + str.format("{0, number, #.####}", t.boxTopPrice2 - (t.boxTopPrice - t.price4)))

        labelTargetPrice3E.set_x(t.boxTime1)
        labelTargetPrice3E.set_y(t.boxTopPrice3)
        labelTargetPrice3E.set_yloc(yloc.price)
        labelTargetPrice3E.set_text("3E=" + str.format("{0, number, #.####}", t.boxTopPrice3))

        labelTargetPrice3N.set_x(t.boxTime1)
        labelTargetPrice3N.set_y(t.boxTopPrice3 - (t.boxTopPrice - t.price4))
        labelTargetPrice3N.set_yloc(yloc.price)
        labelTargetPrice3N.set_text("3N=" + str.format("{0, number, #.####}", t.boxTopPrice3 - (t.boxTopPrice - t.price4)))

        labelTargetPrice4E.set_x(t.boxTime1)
        labelTargetPrice4E.set_y(t.boxTopPrice4)
        labelTargetPrice4E.set_yloc(yloc.price)
        labelTargetPrice4E.set_text("4E=" + str.format("{0, number, #.####}", t.boxTopPrice4))

        labelTargetPrice4N.set_x(t.boxTime1)
        labelTargetPrice4N.set_y(t.boxTopPrice4 - (t.boxTopPrice - t.price4))
        labelTargetPrice4N.set_yloc(yloc.price)
        labelTargetPrice4N.set_text("4N=" + str.format("{0, number, #.####}", t.boxTopPrice4 - (t.boxTopPrice - t.price4)))
        
        labelTargetPrice5E.set_x(t.boxTime1)
        labelTargetPrice5E.set_y(t.boxTopPrice5)
        labelTargetPrice5E.set_yloc(yloc.price)
        labelTargetPrice5E.set_text("5E=" + str.format("{0, number, #.####}", t.boxTopPrice5))

        labelTargetPrice5N.set_x(t.boxTime1)
        labelTargetPrice5N.set_y(t.boxTopPrice5 - (t.boxTopPrice - t.price4))
        labelTargetPrice5N.set_yloc(yloc.price)
        labelTargetPrice5N.set_text("5N=" + str.format("{0, number, #.####}", t.boxTopPrice5 - (t.boxTopPrice - t.price4)))

    // Point D is only labeled if positionned after Time C
    if t.timeD > t.time3
        label.new(t.timeD, t.priceD, "D\n" + str.format("{0, number, ###}", 1 + ((t.timeD - t.time1) / nb_seconds / 1000)) + (labp ? "\n" + str.format("{0, number, #.####}", t.priceD) : ""), xloc.bar_time, yloc.price, pointFillColor, styleABC2, pointTextColor, size.small, text.align_center)
        // Trendlines are drawable since D is visible
        if tren
            line.new(t.time1, t.price1, t.time3, t.price3, xloc=xloc.bar_time, color=tcol, style = line.style_solid, width=twid, extend = extend.both)
            line.new(t.time2, t.price2, t.timeD, t.priceD, xloc=xloc.bar_time, color=tcol, style = line.style_solid, width=twid, extend = extend.both)

    // E-Box: If Point D has been placed after Point C, we have some prediction to make
    if ebox and t.timeD > t.time3
        box.new(t.boxTimeE0, t.boxPriceEBot, t.boxTimeE1, t.boxPriceETop, bgcolor = color.rgb(0,0,0,100), border_color = ecol, xloc = xloc.bar_time, border_width = 1)
        line.new(t.timeD, t.priceD, t.boxTimeE0, t.boxPriceEAnchor, xloc=xloc.bar_time, color=ecol, style = line.style_arrow_right, width=1)
        line.new(t.timeD, t.priceD, t.boxTimeE1, t.boxPriceEAnchor, xloc=xloc.bar_time, color=ecol, style = line.style_arrow_right, width=1)
        labelTargetPriceETop.set_x(t.boxTimeE1)
        labelTargetPriceETop.set_y(t.boxPriceETop)
        labelTargetPriceETop.set_yloc(yloc.price)
        labelTargetPriceETop.set_text(str.format("{0, number, #.####}", t.boxPriceETop))        
        labelTargetPriceEBot.set_x(t.boxTimeE1)
        labelTargetPriceEBot.set_y(t.boxPriceEBot)
        labelTargetPriceEBot.set_yloc(yloc.price)
        labelTargetPriceEBot.set_text(str.format("{0, number, #.####}", t.boxPriceEBot))
        labelBeforeTargetETime.set_x(t.boxTimeE0)
        labelBeforeTargetETime.set_y(t.boxPriceELabels)
        labelBeforeTargetETime.set_yloc(yloc.price)
        labelBeforeTargetETime.set_text(str.format_time(t.boxTimeE0, 'dd-MMM-yyyy\nHH:mm:ss', "UTC+2"))
        labelAfterTargetETime.set_x(t.boxTimeE1)
        labelAfterTargetETime.set_y(t.boxPriceELabels)
        labelAfterTargetETime.set_yloc(yloc.price)
        labelAfterTargetETime.set_text(str.format_time(t.boxTimeE1, 'dd-MMM-yyyy\nHH:mm:ss', "UTC+2"))
        if t.priceD < t.boxPriceELabels
            labelBeforeTargetETime.set_style(label.style_label_down)
            labelAfterTargetETime.set_style(label.style_label_down)

    if ksob and kisu == false
        int pointB = t.time2 - candleTime
        int[] cycles = array.from(0,9,17,26,33,42,51,65,76,83,97,101,151,226)
        for i = array.size(cycles) - 1 to 0
            if array.get(cycles, i) <= ksmx 
                cycle = (array.get(cycles, i) * candleTime) + pointB + (candleTime * ksof)
                if i > 0
                    line.new(cycle, math.min(y1Input, y2Input, y3Input), cycle, math.max(y1Input, y2Input, y3Input), xloc.bar_time, extend.both, color.rgb(33, 149, 243, 50), line.style_dotted, 2)
                label.new(cycle, t.price2, str.format("{0, number, ##}", array.get(cycles, i)), xloc.bar_time, yloc.price, color.rgb(27, 32, 36, 100), label.style_label_left, color.blue )

    if fibo
        var offsetXFiboM = (candleTime * fiboBarOffset) + t.time2
        var offsetXFiboL = offsetXFiboM - (candleTime * fiboBarWidth)
        var offsetXFiboR = offsetXFiboM + (candleTime * fiboBarWidth)
        var fiboScaleColor = color.rgb(31, 205, 187)
        var fiboAxisColor = color.rgb(92, 234, 220)
        var fiboZeroColor = color.rgb(31, 205, 187, 42)

        line.new(t.time3, t.price3, offsetXFiboR, t.price3, xloc = xloc.bar_time, color = fiboZeroColor, width=1, style=line.style_dotted)    // 0%
        labelFibo0.set_x(offsetXFiboR), labelFibo0.set_y(t.price3)

        var fibo23 = 23.6 * ((t.price4 - t.price3) / 100) + t.price3
        line.new(offsetXFiboM, fibo23, offsetXFiboR, fibo23, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 23.6%
        labelFibo23.set_x(offsetXFiboR), labelFibo23.set_y(fibo23)

        var fibo38 = 38.2 * ((t.price4 - t.price3) / 100) + t.price3
        line.new(offsetXFiboM, fibo38, offsetXFiboR, fibo38, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 38.2%
        labelFibo38.set_x(offsetXFiboR), labelFibo38.set_y(fibo38)

        var fibo50 = 50.0 * ((t.price4 - t.price3) / 100) + t.price3
        line.new(offsetXFiboM, fibo50, offsetXFiboR, fibo50, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 50.0%
        labelFibo50.set_x(offsetXFiboR), labelFibo50.set_y(fibo50)

        var fibo61 = 61.8 * ((t.price4 - t.price3) / 100) + t.price3
        line.new(offsetXFiboM, fibo61, offsetXFiboR, fibo61, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 61.8%
        labelFibo61.set_x(offsetXFiboR), labelFibo61.set_y(fibo61)

        var fibo78 = 78.6 * ((t.price4 - t.price3) / 100) + t.price3
        line.new(offsetXFiboM, fibo78, offsetXFiboR, fibo78, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 78.6%
        labelFibo78.set_x(offsetXFiboR), labelFibo78.set_y(fibo78)

        line.new(offsetXFiboM, t.price4, offsetXFiboR, t.price4, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 100%
        labelFibo100.set_x(offsetXFiboR), labelFibo100.set_y(t.price4)

        var fibo123 = 123.6 * ((t.price4 - t.price3) / 100) + t.price3
        line.new(offsetXFiboM, fibo123, offsetXFiboR, fibo123, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 123%
        labelFibo123.set_x(offsetXFiboR), labelFibo123.set_y(fibo123)

        var fibo138 = 138.2 * ((t.price4 - t.price3) / 100) + t.price3
        line.new(offsetXFiboM, fibo138, offsetXFiboR, fibo138, xloc = xloc.bar_time, color = fiboScaleColor, width=1, style=line.style_solid)    // 138%
        labelFibo138.set_x(offsetXFiboR), labelFibo138.set_y(fibo138)

        var fibo161 = 161.8 * ((t.price4 - t.price3) / 100) + t.price3
        line.new(offsetXFiboM, fibo161, offsetXFiboR, fibo161, xloc = xloc.bar_time, color = labelFiboTextColorGold, width=1, style=line.style_solid)    // 161%
        labelFibo161.set_x(offsetXFiboR), labelFibo161.set_y(fibo161)

        var fibo178 = 178.4 * ((t.price4 - t.price3) / 100) + t.price3
        line.new(offsetXFiboM, fibo178, offsetXFiboR, fibo178, xloc = xloc.bar_time, color = labelFiboTextColorGold, width=1, style=line.style_solid)    // 178%
        labelFibo178.set_x(offsetXFiboR), labelFibo178.set_y(fibo178)

        var fibo200 = 200.0 * ((t.price4 - t.price3) / 100) + t.price3
        line.new(offsetXFiboM, fibo200, offsetXFiboR, fibo200, xloc = xloc.bar_time, color = labelFiboTextColorGold, width=1, style=line.style_solid)    // 200%
        labelFibo200.set_x(offsetXFiboR), labelFibo200.set_y(fibo200)        

        line.new(offsetXFiboL, t.price2, offsetXFiboM, t.price2, xloc = xloc.bar_time, color = labelFiboTextColorNeg, width=1, style=line.style_solid)    // 0% at B
        labelFiboN0.set_x(offsetXFiboL), labelFiboN0.set_y(t.price2)    

        var fiboN23 = -23.6 * ((t.price2 - t.price1) / 100) + t.price2
        line.new(offsetXFiboL, fiboN23, offsetXFiboM, fiboN23, xloc = xloc.bar_time, color = labelFiboTextColorNeg, width=1, style=line.style_solid)    // -23.6%
        labelFiboN23.set_x(offsetXFiboL), labelFiboN23.set_y(fiboN23)

        var fiboN38 = -38.2 * ((t.price2 - t.price1) / 100) + t.price2
        line.new(offsetXFiboL, fiboN38, offsetXFiboM, fiboN38, xloc = xloc.bar_time, color = labelFiboTextColorNeg, width=1, style=line.style_solid)    // -38.2%
        labelFiboN38.set_x(offsetXFiboL), labelFiboN38.set_y(fiboN38)

        var fiboN50 = -50.0 * ((t.price2 - t.price1) / 100) + t.price2
        line.new(offsetXFiboL, fiboN50, offsetXFiboM, fiboN50, xloc = xloc.bar_time, color = labelFiboTextColorNeg, width=1, style=line.style_solid)    // -50.0%
        labelFiboN50.set_x(offsetXFiboL), labelFiboN50.set_y(fiboN50)

        var fiboN61 = -61.8 * ((t.price2 - t.price1) / 100) + t.price2
        line.new(offsetXFiboL, fiboN61, offsetXFiboM, fiboN61, xloc = xloc.bar_time, color = labelFiboTextColorNeg, width=1, style=line.style_solid)    // -61.8%
        labelFiboN61.set_x(offsetXFiboL), labelFiboN61.set_y(fiboN61)

        var fiboN78 = -78.6 * ((t.price2 - t.price1) / 100) + t.price2
        line.new(offsetXFiboL, fiboN78, offsetXFiboM, fiboN78, xloc = xloc.bar_time, color = labelFiboTextColorNeg, width=1, style=line.style_solid)    // -78.6%
        labelFiboN78.set_x(offsetXFiboL), labelFiboN78.set_y(fiboN78)

        line.new(offsetXFiboL, t.price1, offsetXFiboM, t.price1, xloc = xloc.bar_time, color = labelFiboTextColorNegCrash, width=1, style=line.style_solid)    // -100%
        labelFiboN100.set_x(offsetXFiboL), labelFiboN100.set_y(t.price1)

        var topAxis = math.max(t.price1, t.price2, fibo200, t.price3)
        var botAxis = math.min(t.price1, t.price2, fibo200, t.price3)
        line.new(offsetXFiboM, botAxis, offsetXFiboM, topAxis, xloc = xloc.bar_time, color = fiboAxisColor, width=1, style=line.style_solid)   // vertical scale axis
        
formatPrice(float predi) =>
    var result = str.format("{0, number, ###}", predi)
    if predi > 1000
        result := str.format("{0, number, ###.###}", predi / 1000) + "K"
    result

drawCtoN(Wave t) =>
    float ratioNAB = 0.0
    int offsetXFiboM = (candleTime * fiboBarOffset) + t.time2
    float ratioN = 100.0 * ((t.price4-t.price3) / t.price3)
    float ratioC = 100.0 * math.abs((t.currentPrice-t.price3) / t.price3) * (t.baNegative ? -1 : 1)
    if t.currentPrice > t.price2
        ratioNAB := t.baNegative ? -100.0 * math.abs((t.price2-t.currentPrice)/(t.price1-t.price2)) : 100.0 * math.abs((t.currentPrice-t.price3)/(t.price4-t.price3))
    else
        ratioNAB := t.baNegative ? 100.0 * math.abs((t.currentPrice-t.price3)/(t.price4-t.price3)) : -100.0 * math.abs((t.price2-t.currentPrice)/(t.price1-t.price2))
    string sratioN = '100% = ' + (ratioN < 0 ? '': '+') + str.format("{0, number, #.##}", ratioN) + ' % C TO N'
    string sratioC = (ratioC < 0 ? '': '+') + str.format("{0, number, #.##}", ratioC) + ' %'
    string sratioNAB = (ratioNAB < 0 ? '' : '+') + str.format("{0, number, #.##}", ratioNAB) + ' %'
    label.new(offsetXFiboM, t.price4, sratioN, xloc.bar_time, yloc.price, color.rgb(255, 153, 0), label.style_label_left, color.rgb(0, 0, 0), size.normal, text.align_center, '', font.family_monospace)
    var labelRatioC = label.new(offsetXFiboM, t.currentPrice, sratioC, xloc.bar_time, yloc.price, color.rgb(96,96,96), label.style_label_right, color.rgb(255, 255, 255), size.normal, text.align_center, '', font.family_monospace)
    var labelRatioNAB = label.new(offsetXFiboM, t.currentPrice, sratioNAB, xloc.bar_time, yloc.price, color.rgb(38,166,154), label.style_label_left, color.rgb(255, 255, 255), size.normal, text.align_center, '', font.family_monospace)
    if (t.baNegative == false and t.currentPrice <= t.price2) or (t.baNegative and t.currentPrice >= t.price2)
        labelRatioC.set_style(label.style_label_left)
        labelRatioNAB.set_style(label.style_label_right)
        labelRatioNAB.set_color(color.rgb(255, 82, 82))

drawSLP(Wave t) =>
    
    // Stupid Linear Prediction
    if tend and t.time4 > t.currentTime
        var nBarOvershoot = 5
        var predi = t.price3 + ((t.currentPrice - t.price3)*(t.time4 - t.time3))/(t.currentTime - t.time3)
        var timeAtOvershoot = t.time4 //t.currentTime + (nBarOvershoot * candleTime)
        var slpPrice = t.price3 + ((t.currentPrice - t.price3)*(timeAtOvershoot - t.time3))/(t.currentTime - t.time3)

        label.new(t.currentTime, na, "SLP=" + formatPrice(predi), xloc.bar_time, yloc.abovebar, color.rgb(132, 0, 255), label.style_label_lower_left, size=size.small, textcolor = color.rgb(255, 255, 255), textalign = text.align_center)
        line.new(t.currentTime, t.currentPrice, timeAtOvershoot, slpPrice, xloc=xloc.bar_time, color=color.purple, style=line.style_arrow_right, width=1)
    
if barstate.isrealtime and not barstate.isconfirmed

    Wave wave = Wave.new()

    wave.price1 := y1Input
    wave.price2 := y2Input
    wave.baNegative := wave.price1 > wave.price2
    wave.time2 := x2Input    
    wave.time3  := x3Input
    wave.price3 := y3Input
    wave.price4 := y3Input + (y2Input - y1Input)
    wave.time4  := x3Input + (x2Input - x1Input)

    wave.currentPrice := close //barstate.islastconfirmedhistory ? close : 1
    wave.currentTime := time //barstate.islastconfirmedhistory ? time : wave.time3
    
    if cton
        drawCtoN(wave)
    drawSLP(wave)

closestLevel(bool baNegative, float d, float n, float e, float n2, float e2) => 
    float level = 0
    if baNegative == false
        if d>n
            level := d-n
        if d>e
            level := d-e
        if d>n2
            level := d-n2
        if d>e2
            level := d-e2
    if baNegative
        if d<n
            level := n-d
        if d<e
            level := e-d
        if d<n2
            level := n2-d
        if d<e2
            level := e2-d
    level

// Draw the indicator on next confirmed tick
if barstate.islastconfirmedhistory

    Wave wave = Wave.new()

    wave.time1  := x1Input
    wave.time2  := x2Input
    wave.time3  := x3Input
    wave.time4  := x3Input + (x2Input - x1Input)
    wave.timeD  := x4Input
    wave.price1 := y1Input
    wave.price2 := y2Input
    wave.price3 := y3Input
    wave.price4 := y3Input + (y2Input - y1Input)                                                                              // N:   
    wave.priceD := y4Input
    wave.baNegative := wave.price1 > wave.price2                                                                              // (B-A) < 0   (A is higher than B)
    wave.retracement := math.abs((wave.price2 - wave.price3) / (wave.price2 - wave.price1) * 100.0)
    wave.nWave  := wave.retracement <= pret ? true : false                                                        // N Wave is a P Wave with less than 50% retracement (will tend to have D outside of AB)
    wave.pWave  := wave.retracement > pret and wave.retracement < 100.0 ? true : false                            // P Wave is an N Wave with more than 50% retracement (will tend to have D staying inside of AB)
    wave.sWave  := wave.retracement >= 100.0 ? true : false                                                                   // S Wave is the premice of a Y Wave with more than 100% of retracement on AB
    wave.lineColor := color.rgb(255, 255, 255, 66)                                                                          // ABCD joints
    wave.arrowColorNS := color.orange                                                                                       // N/S  
    wave.arrowColorEY := color.blue                                                                                         // E/Y  
    wave.arrowColorVSm := color.rgb(255, 82, 102)                                                                           // V/Sm
    wave.arrowColorNtP := color.green                                                                                       // Nt/P
    wave.priceDelta1 := y2Input - y1Input
    wave.priceDelta2 := y3Input - y2Input
    wave.timeDelta1 := x2Input - x1Input
    wave.timeDelta2 := x3Input - x2Input
    wave.boxTime0 := wave.time4 - wave.timeDelta2
    wave.boxTime1 := wave.time4 + wave.timeDelta2
    wave.boxEPrice := (wave.price2 - wave.price1) + wave.price2                                                                 // E:  BD = AB
    wave.boxVPrice := (wave.price2 - wave.price3) + wave.price2                                                                 // V:  CD = BC
    wave.boxNtPrice := (wave.price3 - wave.price1) + wave.price3                                                                // Nt: CD = AC (need 33% retracement of BC over AB)
    wave.boxPPrice := (wave.price1 - wave.price3) + wave.price2                                                                 // P:  CD = B + (A - C)
    wave.boxYPrice := (wave.price1 - wave.price3) + wave.price2                                                                 // Y:  CD = B + (A - C)
    wave.boxSPrice := (wave.price2 - wave.price1) + wave.price3                                                                 // S:  CD = C + (B - A)
    wave.boxSmPrice := (0.5 * (wave.price2 - wave.price3)) + wave.price3                                                        // Sm: CD = C + ((B - C) / 2)
    wave.boxTopPrice := wave.sWave ? wave.boxYPrice : wave.boxEPrice                                                            // Y if S-Wave or (E if N-Wave|P-Wave)
    wave.boxTopPrice2 := 2 * (wave.price4 - wave.price3) + (wave.boxTopPrice - wave.price4) + wave.price3
    wave.boxTopPrice3 := 3 * (wave.price4 - wave.price3) + (wave.boxTopPrice - wave.price4) + wave.price3
    wave.boxTopPrice4 := 4 * (wave.price4 - wave.price3) + (wave.boxTopPrice - wave.price4) + wave.price3
    wave.boxTopPrice5 := 5 * (wave.price4 - wave.price3) + (wave.boxTopPrice - wave.price4) + wave.price3
    float halfADPrice = 0.5 * (math.max(wave.price1, wave.price2, wave.price3, wave.priceD) - math.min(wave.price1, wave.price2, wave.price3, wave.priceD))   // ABCD median (relative)
    wave.midADPrice := wave.baNegative ? wave.price1 - halfADPrice : wave.price1 + halfADPrice                                                                // ABCD mid point (absolute)
    // log.info(str.format("{0, number, #.####}", wave.midADPrice))
    wave.boxPriceEBot := wave.midADPrice
    float deltaEN = wave.boxTopPrice - wave.price4
    wave.boxPriceETop := wave.boxPriceEBot + closestLevel(wave.baNegative, wave.priceD, wave.price4, wave.boxTopPrice, wave.boxTopPrice2 - deltaEN, wave.boxTopPrice2)
    wave.boxTimeE0 := (wave.timeD - wave.time3) + wave.timeD
    wave.boxTimeE1 := (wave.timeD - wave.time1) + wave.timeD
    wave.boxPriceEAnchor := wave.baNegative ? wave.priceD + math.min(wave.boxPriceEBot - wave.priceD, wave.boxPriceETop - wave.priceD) : wave.priceD + math.max(wave.boxPriceEBot - wave.priceD, wave.boxPriceETop - wave.priceD)
    wave.boxPriceELabels := wave.baNegative ? wave.priceD + math.max(wave.boxPriceEBot - wave.priceD, wave.boxPriceETop - wave.priceD) : wave.priceD + math.min(wave.boxPriceEBot - wave.priceD, wave.boxPriceETop - wave.priceD)
    wave.barWidthInPixels := math.abs(bar_index - bar_index[1])
    // log.info(str.format("{0, number, #.##}", wave.retracement) + "% retracement, nWave is " + str.tostring(wave.nWave) + ", pWave is " + str.tostring(wave.pWave) + ", sWave is " + str.tostring(wave.sWave))
    drawIndicator(wave)

if barstate.islast
    
    if kisu or ksob
        table.cell(tab, 0, 0, "Kihon Suchi 9, 17, 26, 33, 42, 51, 65, 76,,,", 17, 3, text_color = color.yellow, text_size = size.small, bgcolor = color.rgb(61, 61, 61))

// Ichimoku stuff
plot(ichi ? conversionLine : na, color=#4385ff, title="Tekan Conversion Line")                                        // TENKAN SEN
plot(ichi ? baseLine : na, color=#f83737, title="Kijun Base Line")                                                    // KIJUN SEN
plot(ichi ? close : na, offset = -displacement + 1, color=#43A047, title="Lagging Chikou Span")
p1 = plot(ichi ? leadLine1 : na, offset = displacement - 1, color=#A5D6A7, title="Leading Senkou Span A")
p2 = plot(ichi ? leadLine2 : na, offset = displacement - 1, color=#EF9A9A, title="Leading Senkou Span B")
//plot(ichi ? (leadLine1 > leadLine2 ? leadLine1 : leadLine2) : na, offset = displacement - 1, title = "Kumo Cloud Upper Line", color = #7eff83, display = display.none)
//plot(ichi ? (leadLine1 < leadLine2 ? leadLine1 : leadLine2) : na, offset = displacement - 1, title = "Kumo Cloud Lower Line", color = #ff6464, display = display.none)
fill(p1, p2, color = leadLine1 > leadLine2 ? color.rgb(67, 160, 71, 90) : color.rgb(244, 67, 54, 90))
plot((ichi and crss) ? (ta.crossover(conversionLine,baseLine) ? baseLine : na) : na,'Crossover',#2157f3,3,plot.style_circles)
plot((ichi and crss) ? (ta.crossunder(conversionLine,baseLine) ? baseLine : na) : na,'Crossunder',#ff5d00,3,plot.style_circles)

// Display of the Tenkan Crossover Gaps
if crss and barstate.islastconfirmedhistory

    lastCrossover = array.get(crossoverBars, array.size(crossoverBars) - 1)
    lastCrossoverDist = array.get(crossoverDist, array.size(crossoverBars) - 1)

    // Kihon Suchi Cycles
    if kisu and ksob == false
        int[] cycles = array.from(0,9,17,26,33,42,51,65,76,83,97,101,151,226)
        for i = array.size(cycles) - 1 to 0
            if array.get(cycles, i) <= ksmx 
                cycle = array.get(cycles, i) + lastCrossBar + ksof
                if i > 0
                    line.new(cycle, math.min(y1Input, y2Input, y3Input), cycle, math.max(y1Input, y2Input, y3Input), xloc.bar_index, extend.both, color.yellow, line.style_dotted, 1)
                label.new(cycle, y2Input, str.format("{0, number, ##}", array.get(cycles, i)), xloc.bar_index, yloc.price, color.rgb(27, 32, 36, 100), label.style_label_left, color.yellow )
        line.new(lastCrossover + lastCrossoverDist, math.min(y1Input, y2Input, y3Input), lastCrossover + lastCrossoverDist, math.max(y1Input, y2Input, y3Input), xloc.bar_index, extend.both, color.rgb(255, 217, 0), line.style_dashed, 1)
        label.new(lastCrossover + lastCrossoverDist, y2Input, str.format("{0, number, ##}", lastCrossoverDist), xloc.bar_index, yloc.price, color.rgb(128, 128, 128, 80), label.style_label_up, color.yellow )

    // Print the list of crossover bars and distances
    for i = array.size(crossoverBars) - 1 to 0
        int v = array.get(crossoverBars, i)
        int d = array.get(crossoverDist, i)
        labelCount := labelCount + 1
        if labelCount <= maxl
            if i == array.size(crossoverBars) - 1
                label.new(v, na, " " + str.format("{0, number, ###}", d) + "\n" + str.format("{0, number, ###}", 1 + bar_index - lastCrossover), xloc.bar_index, yloc.abovebar, color.rgb(255, 0, 0), label.style_arrowdown, color.rgb(117, 188, 255), size.normal)
            else    
                label.new(v, na, " " + str.format("{0, number, ###}", d), xloc.bar_index, yloc.abovebar, color.rgb(255, 0, 0), label.style_arrowdown, color.rgb(117, 188, 255), size.normal)

// EMA
out = ta.ema(src, len)
plot(dema ? out : na, title="EMA Line", color=color.rgb(240, 243, 33), offset=offset, linewidth = 1)
